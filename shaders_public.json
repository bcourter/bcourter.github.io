{
 "userName": "bcourter",
 "date": "2025-12-24T21:24:44.543Z",
 "numShaders": 9,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "clV3Rz",
    "date": "1683553047",
    "viewed": 7246,
    "name": "UGF Intersection",
    "description": "A sharp minmax intersection versus a true SDF intersection of two planes and their offset. All of the cases are UGFs (have unit gradient magnitude).  The SDF and UGF differ only in the normal cone of the original intersection.",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "gradient",
     "ugf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// UGF intersection demo\n// Post 1: https://www.blakecourter.com/2023/05/05/what-is-offset.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.0;\nvec2 direction = vec2(1.0, 1.0);\nbool isSDF = false;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    float interp = clamp(width * 0.5 - abs(a.Distance), 0.0, 1.0);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);    \n\n    wave.Color.a = 0.5 * max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 blend(vec4 c, vec4 base) {\n    return mix(base, c, c.a);\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n    \nImplicit shape(vec2 p){\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));   \n    Implicit minmax = Max(a, b);\n    \n    // Mercury Blend\n    if (false)\n        return IntersectionEuclidean(a, b, 0.0);\n    \n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    Implicit normalCone = Min(aNorm, bNorm);\n\n    // DF-based intersection\n    if (isSDF && normalCone.Distance > 0.0)\n        minmax = Circle(p, center, 0.0, 0.5 * (a.Color + b.Color));\n        \n    return Implicit(minmax.Distance + offset, minmax.Gradient, minmax.Color);\n}\n\nvec4 drawArrow(vec2 p, vec2 mouse, vec4 opColor) {\n    float arrowRadius = 8.0;\n    float arrowSize = 30.0;\n    \n    vec4 annotationColor = vec4(vec3(0.0), 1.0);\n    Implicit cursor = Circle(p, mouse, arrowRadius, annotationColor);\n    opColor = strokeImplicit(cursor, 3.0, opColor);\n    \n    Implicit opMouse = shape(mouse);\n    vec2 delta = (opMouse.Distance * opMouse.Gradient).xy;\n    vec2 boundPt = mouse - delta;\n    \n    vec2 arrowNormal = vec2(delta.y, -delta.x);\n    Implicit arrowSpine = Plane(p, boundPt, arrowNormal, annotationColor);\n    mat2 arrowSideRotation = Rotate2(pi / 12.0);\n    Implicit arrowTip = Max(\n        Plane(p, boundPt, -arrowNormal * arrowSideRotation, annotationColor),\n        Plane(p, boundPt, arrowNormal * inverse(arrowSideRotation), annotationColor)\n    );\n    \n    vec2 spineDir = normalize(delta);\n    vec2 arrowBackPt = boundPt + arrowSize * spineDir;\n    vec2 arrowTailPt = mouse - arrowRadius * spineDir;\n    arrowTip = Max(arrowTip, Max(Negate(cursor), Plane(p, arrowBackPt, delta, annotationColor)));\n    \n    Implicit bound = Shell(Plane(p, 0.5 * (arrowBackPt + arrowTailPt), spineDir, annotationColor), length(arrowBackPt - arrowTailPt), 0.0);\n    if (bound.Distance < 0.0 && dot(spineDir, arrowBackPt - arrowTailPt) < 0.)\n        opColor = strokeImplicit(arrowSpine, 4.0, opColor);\n    \n    return drawFill(arrowTip, opColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    offset = -readFloat(0.) * 400.0 + 200.0;\n    float angle = (-0.5 + readFloat(2.)) * pi;\n    direction = vec2(cos(angle), sin(angle));\n    isSDF = readFloat(1.) > 0.5;\n    \n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));\n    Implicit abOrig = Max(a, b);\n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    \n    Implicit op = shape(p);\n\n    // normal cone\n    if (min(aNorm.Distance, bNorm.Distance) > 0.)\n        opColor = vec4(0.9, 1., 0.9, 1.);\n\n    if (abOrig.Distance > 0.0) {\n        opColor = drawLine(aNorm, opColor);\n        opColor = drawLine(bNorm, opColor);\n    }\n    \n    //detail\n    opColor = drawImplicit(op, opColor);\n\n    opColor = drawLine(a, opColor);\n    opColor = drawLine(b, opColor);\n\n\n    // offset\n    vec2 newCenter = center - offset * normalize(a.Gradient + b.Gradient).xy / cos(0.5 * acos(dot(a.Gradient, b.Gradient)));\n    \n    // offset normal cone\n    if (abOrig.Distance > -offset && offset > 0.) {\n        opColor = drawLine(Plane(p, newCenter, vec2(a.Gradient.y, -a.Gradient.x), a.Color), opColor);\n        opColor = drawLine(Plane(p, newCenter, vec2(b.Gradient.y, -b.Gradient.x), b.Color), opColor);\n    }\n    \n    // swallowtail arc\n    if (isSDF && max(aNorm.Distance, bNorm.Distance) < 0.0) {\n        opColor = drawLine(Circle(p, center, offset, (a.Color + b.Color)), opColor);  \n        opColor = drawLine(Add(a, offset), opColor);\n        opColor = drawLine(Add(b, offset), opColor);\n    }\n\n    Implicit diff = Divide(Subtract(a, b), length(a.Gradient - b.Gradient));\n    diff.Color.a *= 0.5;\n    if (!(isSDF && a.Distance + b.Distance > 0.0))\n        opColor = strokeImplicit(diff, 3.0, opColor);\n\n    opColor = drawArrow(p, mouse, opColor);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,140,160,18);\n\n//////////////////\n// Work in progress\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0),iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Add(a, r), zero);\n    Implicit ub = Max(Add(b, r), zero);\n    \n    Implicit maxab = Max(a, b);\n\n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance < 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    \n    Implicit ab = Min(a, b);\n\n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYBOOLEAN(1,0.0)  _S _D _F      \n    EASYSLIDER(0,0.5)  _O F F S E T  \n    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dtVGRd",
    "date": "1684553994",
    "viewed": 3260,
    "name": "UGF and Traditional Blends",
    "description": "A comparison of blending techniques. Full post here: https://www.blakecourter.com/2023/05/18/field-notation.html",
    "likes": 12,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "ugf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// UGF intersection demo\n// Post 1: https://www.blakecourter.com/2023/05/18/field-notation.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.0;\nvec2 direction = vec2(1.0, 1.0);\nint blend = 0;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    float interp = clamp(width * 0.5 - abs(a.Distance / length(a.Gradient)), 0.0, 1.0);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);    \n\n    wave.Color.a = 0.5 * max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n    \nImplicit shape(vec2 p){\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));   \n    Implicit minmax = Max(a, b);\n    \n    // Mercury Blend\n    if (blend == 1)\n        return Add(IntersectionEuclidean(a, b, 0.0), offset);        \n        \n    // IQ Blend\n    if (blend == 2)\n        return Add(IntersectionSmooth(a, b, 0.), offset);\n        \n    // Rvachev Blend\n    if (blend == 3)\n        return Add(IntersectionRvachev(a, b, 0.0), offset);   \n    \n    // Exponential Blend\n    if (blend == 4)\n        return Add(IntersectionSmoothExp(a, b, 10.), offset);   \n //       return Add(IntersectionSmoothExp(a, b, length(vec2(a.Distance, b.Distance))), offset);   \n    \n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    Implicit normalCone = Min(aNorm, bNorm);\n\n    // DF-based intersection\n    if (blend == 0 && normalCone.Distance > 0.0)\n        minmax = Circle(p, center, 0.0, 0.5 * (a.Color + b.Color));\n        \n        \n    return Implicit(minmax.Distance + offset, minmax.Gradient, minmax.Color);\n}\n\nvec4 drawArrow(vec2 p, vec2 mouse, vec4 opColor) {\n    float arrowRadius = 8.0;\n    float arrowSize = 30.0;\n    \n    vec4 annotationColor = vec4(vec3(0.0), 1.0);\n    Implicit cursor = Circle(p, mouse, arrowRadius, annotationColor);\n    opColor = strokeImplicit(cursor, 3.0, opColor);\n    \n    Implicit opMouse = shape(mouse);\n    vec2 delta = (opMouse.Distance * opMouse.Gradient).xy;\n    vec2 boundPt = mouse - delta;\n    \n    vec2 arrowNormal = vec2(delta.y, -delta.x);\n    Implicit arrowSpine = Plane(p, boundPt, arrowNormal, annotationColor);\n    mat2 arrowSideRotation = Rotate2(pi / 12.0);\n    Implicit arrowTip = Max(\n        Plane(p, boundPt, -arrowNormal * arrowSideRotation, annotationColor),\n        Plane(p, boundPt, arrowNormal * inverse(arrowSideRotation), annotationColor)\n    );\n    \n    vec2 spineDir = normalize(delta);\n    vec2 arrowBackPt = boundPt + arrowSize * spineDir;\n    vec2 arrowTailPt = mouse - arrowRadius * spineDir;\n    arrowTip = Max(arrowTip, Max(Negate(cursor), Plane(p, arrowBackPt, delta, annotationColor)));\n    \n    Implicit bound = Shell(Plane(p, 0.5 * (arrowBackPt + arrowTailPt), spineDir, annotationColor), length(arrowBackPt - arrowTailPt), 0.0);\n    if (bound.Distance < 0.0 && dot(spineDir, arrowBackPt - arrowTailPt) < 0.)\n        opColor = strokeImplicit(arrowSpine, 4.0, opColor);\n    \n    return drawFill(arrowTip, opColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    offset = -readFloat(0.) * 400.0 + 200.0;\n    float angle = (-0.5 + readFloat(2.)) * pi;\n    direction = vec2(cos(angle), sin(angle));\n    blend = int(readFloat(1.) * 6.);\n    \n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));\n    Implicit abOrig = Max(a, b);\n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    \n    Implicit op = shape(p);\n    opColor = drawImplicit(op, opColor);\n\n    opColor = drawLine(a, opColor);\n    opColor = drawLine(b, opColor);\n        \n   // if (abOrig.Distance > 0.0) {\n        opColor = drawLine(aNorm, opColor);\n        opColor = drawLine(bNorm, opColor);\n  //  }\n    \n    vec2 newCenter = center - offset * normalize(a.Gradient + b.Gradient).xy / cos(0.5 * acos(dot(a.Gradient, b.Gradient)));\n    \n  \n\n    Implicit diff = Divide(Subtract(a, b), length(a.Gradient - b.Gradient));\n    diff.Color.a *= 0.5;\n    if (!(a.Distance + b.Distance > 0.0))\n        opColor = strokeImplicit(diff, 3.0, opColor);\n\n    opColor = drawArrow(p, mouse, opColor);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _S _D _F\n    }\n    else if (data.r < 2. * increment){\n        _K O R N D O R F E R\n    }\n    else if (data.r < 3. * increment){\n        _Q U I L E Z\n    }\n    else if (data.r < 4. * increment){\n        _R V A C H E V\n    }\n    else if (data.r < 5. * increment){\n        _E X P O N E N T I A L\n    }\n    else {\n        _M I N M A X\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,6)  _B L E N D _ _T Y P E      \n    EASYSLIDER(0,0.5)  _O F F S E T  \n    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,140,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\n//Implicit Subtract(Implicit a, Implicit b)  {\n//\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n//}\n\nImplicit Subtract(Implicit iA, Implicit iB) { return Add(iA, Negate(iB)); }\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n// exponential smooth smin (IQ)\nImplicit UnionSmoothExp(Implicit a, Implicit b, float k ) {\n    Implicit res = Add(Exp(Multiply(a, -1./k)), Exp(Multiply(b, -1./k)));\n    return Multiply(Log(res), -k);\n}\n\nImplicit IntersectionSmoothExp(Implicit a, Implicit b, float k ) {\n    Implicit res = Add(Exp(Multiply(a, 1./k)), Exp(Multiply(b, 1./k)));\n    return Multiply(Log(res), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "DssczX",
    "date": "1687050585",
    "viewed": 6262,
    "name": "(A+B), (A-B), (A-B) / (A+B)",
    "description": "When working with SDFs, the sum represents local clearance and the difference represents a midsurface.  With unit gradient fields (UGFs), a generalization of SDFs, the sum and difference are always orthogonal fields, creating an interpolation space. ",
    "likes": 20,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "interpolation",
     "ugf",
     "twobody"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// The sum, difference, and two-body fields.\n// Post: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.0;\nvec2 direction = vec2(1.0, 1.0);\nint viz = 4;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    float angle = (-0.5 + readFloat(2.)) * pi;\n    direction = vec2(cos(angle), sin(angle));\n    viz = int(readFloat(1.) * 5.);\n    \n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    float padding = iResolution.x * (0.3 + cos(iTime) * 0.05);\n    float size = iResolution.x * 0.1 + sin(iTime) * 12.0;\n\n    Implicit a = RectangleUGFSDFCenterRotated(fragCoord, vec2(padding, iResolution.y / 2.0), size * 1.8, iTime * 0.1, vec4(1., 0., 0., 1));\n //   Implicit a = RectangleCenterRotated(fragCoord, vec2(padding, iResolution.y / 2.0), vec2(size * 1.8), iTime * 0.1, vec4(1., 0., 0., 1));\n    Implicit b = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), size, vec4(0., 0., 1., 1));\n    \n    Implicit shapes = Min(a, b);\n    Implicit sum = Add(a, b);   \n    Implicit diff = Subtract(a, b);\n    Implicit interp = Divide(diff, sum);\n    \n    switch (viz) {\n    case 0:\n        opColor = drawImplicit(shapes, opColor);\n        break;\n    case 1:\n        opColor = drawImplicit(Multiply(sum, 0.5), opColor);\n        break;\n    case 2:\n        opColor = drawImplicit(Multiply(diff, 0.5), opColor);\n        break;\n    case 3:\n        opColor = min(\n            drawImplicit(Multiply(sum, 0.5), opColor),\n            drawImplicit(Multiply(diff, 0.5), opColor)\n        );\n        break;\n    default:\n        opColor = min(\n            drawImplicit(Multiply(interp, 100.), opColor),\n            drawImplicit(Multiply(Subtract(1., Abs(interp)), 100.), opColor)\n        );\n        break;\n    }\n    \n    if (shapes.Distance < 0.)\n        opColor.rgb = min(opColor.rgb, opColor.rgb * 0.65 + shapes.Color.rgb * 0.2);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n //   opColor = DrawVectorField(p3, Divide(shape, length(shape.Gradient)), opColor, 25., 1.);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _A _ A N D _ _B\n    }\n    else if (data.r < 2. * increment){\n        _A _ PLUS _ _B\n    }\n    else if (data.r < 3. * increment){\n        _A _ MINUS _ _B\n    }\n    else if (data.r < 4. * increment){\n        _A _ PLUS _ _B _ A N D _ _A _ MINUS _ _B\n    }\n    else {\n        LPAREN _A _ MINUS _ _B RPAREN _ SLASH _ LPAREN _A _ PLUS _ _B RPAREN\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,4.0,5)  _V I S U A L I Z A T I O N      \n//    EASYSLIDER(0,0.5)  _O F F S E T  \n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "dd2cWy",
    "date": "1688223883",
    "viewed": 1358,
    "name": "UGF Sum and Diff are Orthogonal",
    "description": "The sum and difference of unit gradient fields are orthogonal.  Good luck using this property for mapping.  Illustation for: https://www.blakecourter.com/2023/07/01/two-body-field.html",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "ugf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// The sum and difference fields are orthogonal  \n// Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 center = vec2(0.0);\nvec2 direction = vec2(1.0, 1.0);\nbool isSDF = false;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    float interp = clamp(width * 0.5 - abs(a.Distance), 0.0, 1.0);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);    \n\n    wave.Color.a = 0.5 * max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 blend(vec4 c, vec4 base) {\n    return mix(base, c, c.a);\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n  //  if (a.Distance <= 0.0)\n    float d = clamp(a.Distance + 0.5, 0., 1.);\n    return mix(opColor, a.Color, mix(a.Color.a, 0., d));\n\n    return opColor;\n}\n\nvec4 white = vec4(1.);\nvec4 black = vec4(vec3(0.), 1.);   \nfloat pointRadius = 5.0;  \nfloat arrowRadius = 8.0;\nfloat arrowSize = 30.0;\n    \nvec4 drawPoint(vec2 p, vec2 center, vec4 opColor) {\n    Implicit circle = Circle(p, center, pointRadius, white);\n    opColor = drawFill(circle, opColor);\n    circle.Color = black;\n    return strokeImplicit(circle, 3.0, opColor);\n}\n\nvec4 drawArrow(vec2 p, vec2 startPt, vec2 endPt, vec4 color, vec4 opColor) {\n    vec2 delta = startPt - endPt;\n    vec2 arrowNormal = vec2(delta.y, -delta.x);\n    Implicit arrowSpine = Plane(p, endPt, arrowNormal, color);\n    mat2 arrowSideRotation = Rotate2(pi / 12.0);\n    Implicit arrowTip = Max(\n        Plane(p, endPt, -arrowNormal * arrowSideRotation, color),\n        Plane(p, endPt, arrowNormal * inverse(arrowSideRotation), color)\n    );\n    \n    vec2 spineDir = normalize(delta);\n    vec2 arrowBackPt = endPt + arrowSize * spineDir;\n    vec2 arrowTailPt = startPt;\n\n    arrowTip = Max(arrowTip, Plane(p, arrowBackPt, delta, color));\n    \n    Implicit bound = Shell(Plane(p, 0.5 * (arrowBackPt + arrowTailPt), spineDir, color), length(arrowBackPt - arrowTailPt), 0.0);\n    if (bound.Distance < 0.0 && dot(spineDir, arrowBackPt - arrowTailPt) < 0.)\n        opColor = strokeImplicit(arrowSpine, 4.0, opColor);\n    \n    return drawFill(arrowTip, opColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    float angledot = readFloat(2.) - 0.5 + 0.1 * sin(iTime);\n    float angle = angledot * pi;\n    direction = vec2(cos(angle), sin(angle));\n    isSDF = readFloat(1.) > 0.5;\n    \n    vec2 p = (fragCoord - vec2(0.5, 0.333) * iResolution.xy); // * iResolution.xy;    \n\n    // planes\n    Implicit a = Plane(p, center, vec2(0.0, 1.0), vec4(1.0, 0.0, 0.0, 1.0));\n    Implicit b = Plane(p, center, direction, vec4(0.0, 0.0, 1.0, 1.0));\n    Implicit abOrig = Max(a, b);\n    Implicit aNorm = Plane(p, center, vec2(a.Gradient.y, -a.Gradient.x), a.Color);\n    Implicit bNorm = Plane(p, center, vec2(-b.Gradient.y, b.Gradient.x), b.Color);\n    \n    \n    // normal cone\n    if (min(aNorm.Distance, bNorm.Distance) > 0.)\n        opColor = vec4(0.9, 1., 0.9, 1.);\n        \n        \n    float size = iResolution.y * 0.33;\n    Implicit unitCircle = Circle(p, center, size, vec4(vec3(0.), 0.25));\n    opColor = strokeImplicit(unitCircle, 2., opColor);\n\n    opColor = drawLine(aNorm, opColor);\n    opColor = drawLine(bNorm, opColor);\n    \n    // layout\n    opColor = drawImplicit(a, opColor);\n    opColor = drawImplicit(b, opColor);\n\n    opColor = drawLine(a, opColor);\n    opColor = drawLine(b, opColor);\n\n    Implicit sum = Add(a, b);\n    Implicit diff = Subtract(a, b);\n\n    // arrows\n    vec2 pointA = center + size * a.Gradient.xy;    \n    vec2 pointB = center + size * b.Gradient.xy;\n    vec2 sumVec = size * sum.Gradient.xy;\n    vec2 pointAB = center + sumVec;\n    \n    vec4 red = vec4(0.5, 0., 0., 1.0);    \n    vec4 blue = vec4(0., 0., 0.5, 1.0);\n    opColor = drawArrow(p, center, pointA, red, opColor);\n    opColor = drawArrow(p, center, pointB, blue, opColor); \n    red.a = 0.5;\n    blue.a = 0.5;    \n    opColor = drawArrow(p, pointA, pointAB, blue, opColor);\n    opColor = drawArrow(p, pointB, pointAB, red, opColor);\n    \n    if (abs(angledot) != 0.5) {\n        opColor = drawArrow(p, center, pointAB, black, opColor); // sum\n        opColor = drawArrow(p, pointB, pointA, black, opColor); // diff\n    }\n    \n    opColor = drawPoint(p, center, opColor);    \n    opColor = drawPoint(p, pointA, opColor);    \n    opColor = drawPoint(p, pointB, opColor);    \n    opColor = drawPoint(p, pointAB, opColor);\n    \n    // perp square\n    float perpSize = 12.;\n    float halfPerpSize = perpSize * 0.5;\n    Implicit square = Max(Abs(Subtract(Sampson(sum), halfPerpSize + 0.5 * length(sumVec))), Abs(Subtract(Sampson(Negate(diff)), halfPerpSize)));\n    square = Subtract(square, halfPerpSize);\n    square.Color = black;\n    opColor = strokeImplicit(square, 3., opColor);\n\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n// Work in progress\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0),iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\nImplicit Sampson(Implicit a) {\n    return Multiply(1. / length(a.Gradient), a);\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Add(a, r), zero);\n    Implicit ub = Max(Add(b, r), zero);\n    \n    Implicit maxab = Max(a, b);\n\n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance < 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    \n    Implicit ab = Min(a, b);\n\n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * 2. - 1., prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "cs2cW3",
    "date": "1688263522",
    "viewed": 1315,
    "name": "Two Body Apollonian and Conics",
    "description": "Apollonian circles and conic sections via the two-body field.  Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "ugf",
     "twobody"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Apollonian and conic two-body fields\n// Illustration for: https://www.blakecourter.com/2023/07/01/two-body-field.html\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat offset = 0.5;\nvec2 direction = vec2(1.0, 1.0);\nint viz = 0;\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 opColor = mix(base, a.Color, (a.Distance < 0.0 ? a.Color.a * 0.1 : 0.0));\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    if (a.Distance <= 0.0)\n        return mix(opColor, a.Color, a.Color.a);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    offset = readFloat(0.);\n    viz = int(readFloat(1.) * 2.);\n    \n    vec2 p = fragCoord - 0.5 * iResolution.xy; // * iResolution.xy;\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    float paddingAmt = 0.33;\n    float padding = iResolution.x * paddingAmt; // * (0.3 + cos(iTime) * 0.05);\n    float size = iResolution.x * (0.5 - paddingAmt) * sin(iTime) * offset;   \n    \n    Implicit a;\n    vec2 aCenter = vec2(padding, iResolution.y / 2.0);\n    float aRadius = size;\n    vec4 red = vec4(1., 0., 0., 1);\n    switch (viz) {\n    case 0:\n        a = Circle(fragCoord, aCenter, aRadius, red);\n        break;\n    default:\n        a = Plane(fragCoord, aCenter + vec2(aRadius, 0.), vec2(1, 0), red);\n    }\n \n    \n    Implicit b = Circle(fragCoord, vec2(iResolution.x - padding, iResolution.y / 2.0), -size, vec4(0., 0., 1., 1));\n    \n    Implicit shapes = Min(a, b);\n    Implicit sum = Add(a, b);   \n    Implicit diff = Subtract(a, b);\n    Implicit interp = Divide(diff, sum);\n    \n    opColor = min(\n        drawImplicit(Multiply(interp, 100.), opColor),\n        drawImplicit(Multiply(Subtract(1., Abs(interp)), 100.), opColor)\n    );\n \n \n    if (shapes.Distance < 0.)\n        opColor.rgb = min(opColor.rgb, opColor.rgb * 0.65 + shapes.Color.rgb * 0.2);\n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n //   opColor = DrawVectorField(p3, Divide(shape, length(shape.Gradient)), opColor, 25., 1.);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 2.));\n    if (data.r * 2. < increment) {\n        _A P O L L O N I A N\n    }\n    else {\n        _C O N I C S\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,1)  _V I S U A L I Z A T I O N      \n    EASYSLIDER(0,0.2)  _W I G G L E\n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,100,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mt2BDG",
    "date": "1694457889",
    "viewed": 646,
    "name": "LatticeRobot GLSL Interop Beta",
    "description": "The first prototype of LatticeRobot's GLSL export are in the contents of the \"Common\" tab.  Feedback welcome.  \n\nThis ability is WIP at https://www.latticerobot.com .\n\nTBD:\n* Parameter metadata\n* Function call instead of uniforms/globals?",
    "likes": 6,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "sdf",
     "diamond",
     "gyroid",
     "lattice",
     "tpms",
     "latticerobot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n//\n// Please see the \"Common\" tab for LatticeRobot interop.  \n//\n// This renderer is similar to the one used by LatticeRobot, derived from IQ and related \n// ShaderToys as commented below.  \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Sliders\n\nfloat cellCount = 1.0;\n\nfloat readFloat(float address) { \n    return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; \n}\n\nvoid updateParams() {\n    float latticeIndexFloat = readFloat(0.) * 4.;\n    latticeIndex = latticeIndexFloat >= 4. ? 3 : int(latticeIndexFloat);\n    size_x = readFloat(1.) * 10.0 + 5.0;\n    size_y = readFloat(2.) * 10.0 + 5.0;\n    size_z = readFloat(3.) * 10.0 + 5.0;\n    bias = readFloat(4.) * 5.0 - 2.5;\n    thickness = readFloat(5.) * 5.0;\n    drop_x = readFloat(6.);\n    drop_y = readFloat(7.);\n    drop_z = readFloat(8.);\n    gyroid = readFloat(9.);\n    cellCount = readFloat(10.) * 3.0 + 1.0;\n}\n\n// ColorImplicit\n\nconst float cHigh = 0.8;\nconst float cMed = 0.7;\nconst float cLow = 0.3;\nconst vec4 colorCool = vec4(cMed, cMed, cHigh, 1.0);\nconst vec4 colorWarm = vec4(cHigh, cMed, cMed, 1.0);\nconst vec4 colorLightGray = vec4(cHigh, cHigh, cHigh, 1.0);\n\nstruct ColorImplicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nColorImplicit CreateColorImplicit(Implicit implicit, vec4 color) {\n    return ColorImplicit(implicit.Distance, implicit.Gradient, color);\n}\n\nColorImplicit Max(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\n// IQ rendering https://www.shadertoy.com/view/wlXSD7\nColorImplicit map(vec3 p) {\n    float amp = 0.05;\n    vec3 pOrig = p * vec3(1.0 + amp * cos(iTime), 1.0 + amp * cos(iTime), 1.0 + amp * sin(iTime));  // play with size\n    p = pOrig + center;\n\n    Implicit merged = Divide(scaledLattice(pOrig * cellCount + center), cellCount);\n\n    Implicit bounds = BoxCenter(p, center, 0.1 * vec3(size_x, size_y, size_z));\n\n    float bumpOffset = 0.05;\n    float bump = pow(abs(cos((1.5 * iTime + p.z) * 0.4)), 400.);\n    Implicit offset = Add(merged, -bump * bumpOffset);\n    \n    vec4 baseColor = latticeIndex == 1 ? colorWarm : colorCool;\n    ColorImplicit colorField = CreateColorImplicit(offset, baseColor);\n    if (latticeIndex > 1) {\n        int tmp = latticeIndex;\n        latticeIndex = 0; // override to see what axis we are on\n        colorField.Color = (Divide(scaledLattice(pOrig * cellCount + center), cellCount).Distance > 0.0) ?\n            colorCool : colorWarm;\n            \n           \n        latticeIndex = tmp;\n    }\n    \n    colorField.Color = colorField.Color + vec4(bump * 0.2);\n    ColorImplicit colorBox = CreateColorImplicit(bounds, colorLightGray);\n    return Max(colorField, colorBox);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0)  *0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).Distance + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).Distance + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).Distance + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).Distance );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadowBanding( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).Distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd).Distance;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// advanced via https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).Distance;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            // float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).Distance;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    updateParams();\n\n    float rad = 1.25;\n    float lightAng = 0.0;\n\tvec3 ro = vec3( rad*cos(lightAng), rad*sin(lightAng), 0.7 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n    mat3 rot = RotateZ(an);\n    mat3 rotInv = RotateZ(-an);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.5;\n    float t = 0.0;\n    ColorImplicit hit;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = (ro + t*rd) * rot;\n        hit = map(pos);\n        if( hit.Distance < 0.0001 || t > tmax ) break;\n        t += hit.Distance * 0.35;  // slow down to not miss sharp features and TPMS with Lipschitz > 1.  (TBD figure out why this value doesn't work at 0.9)\n    }\n\n    if (t > tmax)\n        tot = vec3(1.0);\n\n    vec3 nor;\n\n#if 0    // 1 for simple renderer\n    // shading/lighting\t\n    vec3 col = vec3(0.0);\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        //vec3 nor = calcNormal(pos);  // numerical gradient\n        nor = normalize(hit.Gradient);\n\n       float dif = clamp( dot(nor, vec3(0.8, 0., 0.6) * rot ), 0.0, 1.0 );\n        float amb = 0.5 ;\n        col = vec3(0.6)*amb + vec3(1.)*dif;\n        col = col * hit.Color.rgb;\n    }\n#else\n    // shading/lighting\t\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 pos = (ro + t*rd) * rot;\n        nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n        vec3 lig = normalize(vec3(0.6,0.0,0.4)) * rot;\n        vec3 hal = normalize(lig-rd*rot);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float occ = calcOcclusion( pos, nor );\n        if( dif>0.001 ) dif *= softshadow( pos, lig, 0.0001, 1.0, 0.2 );\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd*rot),0.0,1.0),5.0));\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.0,1.0));\n        col =  hit.Color.rgb * amb*occ;\n        col += hit.Color.rgb * dif * 0.8;\n\n        col *= 0.8;\n\n        col += vec3(1.,1.,1.)*spe*2.0;\n    }\n#endif\n          \n\ttot += col;\n\tfragColor = vec4( tot, 1.0 );\n    \n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n// This code in the 'Common' tab is test output from LatticeRobot's lattice CodeRep generator.  \n// It is intended for other implicits to use to fill shapes with spatially varying lattices.\n//\n// https://www.latticerobot.com\n//\n// LICENSE: This code is provided under an MIT license.  \n// BETA WARNING: This format will evolve through the fall of 2023\n//\n// Documentation:\n// Immediately below, there is a library, followed by the custom code for this parameterized\n// unit cell (line 336).  A complier directive replaces the uniforms with internal parameters\n// for the purpose of this Shadertoy demo.\n//\n// Lattice Variants and Index:\n// The latticeIndex uniform accesses the four variants of the lattice F(p), with the shape \n// defined by the preimage of the non-positive values of that variant:\n//\n//   0: Solid. The Solid lattice:\n//       F(p) - bias\n//\n//   1: Inverse. The inverse of the Solid lattice:\n//       -F(p) + bias\n//\n//   2: Thin. A thin band of the Solid lattice:\n//       abs(F(p) - bias) - thickness / 2\n//\n//   3: Twin. The twin axes produced by the inverse of the Thin lattice:\n//       -abs(F(p) - bias) + thickness / 2\n//\n// Common Lattice Parameters (with default value and units):\n//   * size_x, size_y, and size_z (10 mm): The dimensions of the desired bounding box. \n//   * bias (0 mm): The offset of the baseline lattice surface.  Not precise distance.\n//   * thickness (1 mm): Thin and Twin only.  The thickness of the wall of the thin lattice or\n//        the span of the spacing of the twin lattice.  Not precise distance.\n//\n// Special Lattice Parameters (for only this lattice):\n//   * drop_x, drop_y, and drop_z (1): Lattice-specific parameters that attenuate coefficients.\n//   * gyroid (0): interpolates the Diamond TPMS to Gyroid TPMS.  \n//  \n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// LatticeRobot Library\n\n#define PI 3.14159265358979\n#define SQRT2 1.41421356237\n#define SQRT3 1.73205080757\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0)); }\n\nImplicit mix(Implicit a, Implicit b, float t) {\n    return Implicit(\n        mix(a.Distance, b.Distance, t),\n        mix(a.Gradient, b.Gradient, t)\n    );\n}\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance));\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b); }\n\nImplicit Min(Implicit a, Implicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Min(Implicit a, Implicit b, Implicit c) { return Min(a, Min(b, c)); }\nImplicit Min(Implicit a, Implicit b, Implicit c, Implicit d) { return Min(a, Min(b, Min(c, d))); }\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Max(Implicit a, Implicit b, Implicit c) { return Max(a, Max(b, c)); }\nImplicit Max(Implicit a, float b) { return Max(a, CreateImplicit(b)); }\nImplicit Max(Implicit a, Implicit b, Implicit c, Implicit d) { return Max(a, Max(b, Max(c, d))); }\n\nImplicit Compare(Implicit iA, Implicit iB) {\n    if (iA.Distance < iB.Distance)\n        return CreateImplicit(-1.0);\n        \n    if (iA.Distance > iB.Distance)\n        return CreateImplicit(1.0);\n\n    return CreateImplicit(0.0);\n}\nImplicit Compare(Implicit iA, float iB) { return Compare(iA, CreateImplicit(iB)); }\n\nImplicit Exp(Implicit iImplicit) {\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient);\n}\n\nImplicit Log(Implicit iImplicit) {\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance);\n}\n\nImplicit Pow(Implicit iMantissa, Implicit iExponent) {\n    float result = pow(iMantissa.Distance, iExponent.Distance);\n\treturn Implicit(result, result * log(iMantissa.Distance) * iMantissa.Gradient);\n}\n\nImplicit Sqrt(Implicit iImplicit) {\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt));\n}\n\nImplicit Square(Implicit iImplicit) {\n\tfloat square = iImplicit.Distance * iImplicit.Distance ;\n\treturn Implicit(square, 2. *  square * iImplicit.Gradient);\n}\n\nImplicit Abs(Implicit iImplicit) {\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Sin(Implicit iImplicit) {\n\treturn Implicit(sin(iImplicit.Distance), cos(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Cos(Implicit iImplicit) {\n\treturn Implicit(cos(iImplicit.Distance), -sin(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Tan(Implicit iImplicit) {\n    float sec = 1. / cos(iImplicit.Distance);\n\treturn Implicit(tan(iImplicit.Distance), sec * sec * iImplicit.Gradient);\n}\n\nvec3 Boundary(vec3 iP, Implicit i) {\n    return -i.Distance * i.Gradient;\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) {\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ua = Subtract(a, radius);\n    Implicit ub = Subtract(b, radius);\n\n    Implicit ab = Min(ua, ub);\n\n    if (max(ua.Distance, ub.Distance) < 0.) {\n        ab = Negate(EuclideanNorm(ua, ub));\n    }\n\n    return Add(ab, radius);\n}\n\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    return Negate(UnionEuclidean(Negate(a), Negate(b), radius));\n}\n\nImplicit IntersectionSmoothExp(Implicit a, Implicit b, float radius) {\n    return Negate(UnionEuclidean(Negate(a), Negate(b), radius));\n}\n\n\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n\n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n\n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n\n    vec3 bary = 0.33 * vec3(ua.Distance, ub.Distance, uc.Distance) / (ua.Distance + ub.Distance + uc.Distance);\n\n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n\n    return result;\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n\n    return result;\n}\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal) {\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal) {\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius) {\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0));\n}\n\nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, -sa * p.y + ca * p.z, ca * p.y + sa * p.z);\n}\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\nImplicit Sphere(vec3 iP, vec3 iCenter, float iRadius) {\n\tvec3 centered = iP - iCenter;\n    float length = length(centered);\n\tfloat dist = length - iRadius;\n\treturn Implicit(dist, centered / length);\n}\n\nImplicit BoxCenter(vec3 iP, vec3 iCenter, vec3 iSize) {\n\tvec3 p = iP - iCenter;\n\tvec3 b = iSize * 0.5;\n\n\tvec3 d = abs(p)-b;\n\tfloat dist = length(max(d, vec3(0.))) + min(max(d.x, max(d.y, d.z)), 0.);\n\n\tvec3 grad = (d.x > d.y) && (d.x > d.z) ? vec3(1., 0., 0.) :\n\t\t(d.y > d.z ? vec3(0., 1., 0.) : vec3(0., 0., 1.));\n\n\tif (d.x > 0. || d.y > 0. || d.z > 0.)\n\t{\n\t\td = max(d, 0.);\n\t\tgrad = d / length(d);\n\t}\n\n\tgrad *= sign(p);\n\n\treturn Implicit(dist, grad);\n}\n\nImplicit Box(vec3 iP, vec3 iA, vec3 iB) {\n\tvec3 center = (iA + iB) * 0.5;\n\tvec3 size = abs(iA - iB);\n\treturn BoxCenter(iP, center, size);\n}\n\nconst vec3 center = vec3(0.5);\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// LatticeRobot Unique Unit Cell\n\n#if 0\nuniform int latticeIndex;\nuniform float size_x;\nuniform float size_y;\nuniform float size_z;\nuniform float bias;\nuniform float thickness;\nuniform float drop_x;\nuniform float drop_y;\nuniform float drop_z;\nuniform float gyroid;\n#else\nint latticeIndex = 2;\nfloat size_x = 10.0;\nfloat size_y = 10.0;\nfloat size_z = 10.0;\nfloat bias = 0.0;\nfloat thickness = 1.0;\nfloat drop_x = 1.0;\nfloat drop_y = 1.0;\nfloat drop_z = 1.0;\nfloat gyroid = 0.0;\n#endif\n\nfloat supremum = SQRT2;\n\nImplicit mix(Implicit a, float b, float t) {\n  float _mix_000 = 1.0 - t;\n  Implicit _mix_001 = Multiply(_mix_000, a);\n  float _mix_002 = t * b;\n  Implicit _mix_003 = Add(_mix_001, _mix_002);\n  return _mix_003;\n}\n\nImplicit solidLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit solid = lattice;\n  return solid;\n}\n\nImplicit inverseLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit inverse = Multiply(-1.0, lattice);\n  return inverse;\n}\n\nImplicit thinLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit _thin_000 = Abs(lattice);\n  float _thin_001 = thickness * 0.5;\n  Implicit thin = Subtract(_thin_000, _thin_001);\n  return thin;\n}\n\nImplicit twinLattice(vec3 p) {\n  Implicit thin = thinLattice(p);\n  Implicit twin = Multiply(-1.0, thin);\n  return twin;\n}\n\nImplicit indexedLattice(vec3 p) {\n  switch (latticeIndex) {\n    case 0: return solidLattice(p);\n    case 1: return inverseLattice(p);\n    case 2: return thinLattice(p);\n    case 3: return twinLattice(p);\n  }\n  return Sphere(p, vec3(0.0), 5.0);\n}\n\nImplicit scaledLattice(vec3 scaledP) {\n  vec3 p = (scaledP - center) * 10.0;\n  Implicit lattice = indexedLattice(p);\n  return Divide(lattice, 10.0);\n}\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n//\n// Please see the \"Common\" tab for LatticeRobot interop.  \n// This buffer is for the ShaderToy sliders.\n//\n// This slider approach is slow.  Expect a replacement. \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Sliders from work ceated by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n// NON MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n\nvec4 bounds = vec4(30,410,160,18);\n\n#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float minval, float maxval, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * (maxval - minval) + minval, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, float minval, float maxval, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, minval, maxval, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _S O L I D\n    }\n    else if (data.r < 2. * increment){\n        _I N V E R S E\n    }\n    else if (data.r < 3. * increment){\n        _T H I N\n    }\n    else {\n        _T W I N\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n#define EASYSLIDER(id,val,minval,maxval) drawSlider(id, val, minval, maxval, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(0, 2.0, 4)  _V A R I A N T   \n    EASYSLIDER(10, 0.0, 1.0, 4.0)  _C O U N T   \n    EASYSLIDER(1, 0.5, 5.0, 15.0)  _S I Z E _ _X    \n    EASYSLIDER(2, 0.5, 5.0, 15.0)  _S I Z E _ _Y    \n    EASYSLIDER(3, 0.5, 5.0, 15.0)  _S I Z E _ _Z          \n    EASYSLIDER(4, 0.5, -2.5, 2.5)  _B I A S  \n    EASYSLIDER(5, 0.5, 0.0, 5.0)  _T H I C K N E S S   \n    EASYSLIDER(6, 1.0, 0.0, 1.0)  _D R O P _ _X    \n    EASYSLIDER(7, 1.0, 0.0, 1.0)  _D R O P _ _Y    \n    EASYSLIDER(8, 1.0, 0.0, 1.0)  _D R O P _ _Z    \n    EASYSLIDER(9, 0.0, 0.0, 1.0)  _G Y R O I D   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    fragColor=result;    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "mtKfWz",
    "date": "1702002136",
    "viewed": 1203,
    "name": "Angular Derivative",
    "description": "Taking the angular derivative with respect to an axis, which is an orthogonal field to the original SDF.  From there, we can make a pencil of surfaces through the intersection of the SDF and the derivative.",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "derivative",
     "pencil",
     "differential",
     "ugf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Derivative of a field with respect to a rotation axis\n// See blog post at: https://www.blakecourter.com/2024/04/12/differential-engineering.html\n\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat wobble = 0.0;\nint shapeIndex = 0;\n\nvec4 colorWarm = vec4(1, 0, 0, 1);\nvec4 colorCool = vec4(0, 0, 1, 1);\nvec4 colorBlack = vec4(0, 0, 0, 1);\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 color = a.Distance > 0.0 ? colorWarm : colorCool;\n    vec4 opColor = mix(base, color, 0.1);\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    float clamped = 0.5 - clamp(a.Distance / length(a.Gradient), -0.5, 0.5);\n    return mix(opColor, a.Color, a.Color.a * clamped);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    wobble = readFloat(0.); \n    shapeIndex = int(readFloat(1.) * 3.);\n\n    float halfGolden = 0.5*0.618;\n    vec2 size = iResolution.x * 0.2 * vec2(1.0 + halfGolden * (1.0 + cos(iTime) * wobble), 1.0) + vec2(160.0 * wobble * cos(iTime * 0.5));\n\n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    else\n        mouse = shapeIndex == 0 ? vec2(0.0) : vec2(size.x * 0.5, 0.0);\n        \n    if (iMouse.xy == vec2(0.0)) \n        mouse = vec2(0.0);\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    Implicit shape;\n    if (shapeIndex == 0) {\n        shape = RectangleCenterRotated(p - mouse, vec2(0.0), size, 0.0, colorBlack);\n    } else if (shapeIndex == 1){\n        shape = Circle(p - mouse, center, size.x * 0.5, colorBlack);\n    } else {\n        shape = Plane(p - mouse, center, mouse - center, colorBlack);\n    }\n    \n    // uncomment for squared Euclidean metric\n    // shape.Distance = shape.Distance * shape.Distance * sign(shape.Distance) * 0.01;\n    \n    vec2 pRot = vec2(p.y, -p.x);\n    vec3 gradRot = vec3(shape.Gradient.y, -shape.Gradient.x, 0.0);\n    \n    //    opColor = drawImplicit(shape, opColor);    \n    Implicit grad = Implicit(dot(pRot, shape.Gradient.xy), gradRot, vec4(0., 0., 0., 1));\n    float rotateTime = iTime * 0.25;\n    Implicit pencilA = Add(Multiply(cos(rotateTime), shape), Multiply(sin(rotateTime), grad));\n    Implicit pencilB = Add(Multiply(-sin(rotateTime), shape), Multiply(cos(rotateTime), grad));\n    \n    opColor = drawImplicit(pencilA, opColor);\n    opColor = drawImplicit(pencilB, opColor);\n    opColor = strokeImplicit(shape, 5.0, opColor);\n    \n    Implicit axis = Circle(p, center, 5.0, colorBlack);\n    opColor = drawFill(axis, opColor);    \n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://iquilezles.org/articles/smin/\nImplicit IntersectionExponential(Implicit a, Implicit b, float radius) {\n//    float res = exp2( -a/k ) + exp2( -b/k );\n//    return -k*log2( res );\n\n    a = Exp(Divide(a, radius));\n    b = Exp(Divide(b, radius));\n    Implicit res = Add(a, b);\n    \n    return Multiply(Log(res), radius);\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\n\n\nImplicit RectangleCenterRotatedExp(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    size = size * 0.5;\n    Implicit xPlane = Subtract(Abs(Implicit(centered.x, vec3(1, 0, 0), color)), size.x);\n    Implicit yPlane = Subtract(Abs(Implicit(centered.y, vec3(0, 1, 0), color)), size.y);\n\n\n    \n\treturn IntersectionExponential(xPlane, yPlane, 20.0);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _R E C T A N G L E\n    }\n    else if (data.r < 2. * increment) {\n        _C I R C L E\n    } else {\n        _L I N E\n    }\n   \n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,3)  _S H A P E      \n    EASYSLIDER(0,0.5)  _W O B B L E  \n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4f2XzW",
    "date": "1706105276",
    "viewed": 938,
    "name": "Derivatives of Rectangle",
    "description": "Let's look at the derivatives of a rectangle.  In the SDF of the rectangle, we color by averaging in binary operations like sum, illustrating parameter contribution by count.  For the two derivatives, red is zero and blue is one.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "derivative",
     "differential",
     "ugf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Derivatives of an exact rectangle SDF \n// Blog post: https://www.blakecourter.com/2024/04/12/differential-engineering.html\n\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat wobble = 0.0;\nint shapeIndex = 0;\n\n// siders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    vec4 color = a.Distance > 0.0 ? colorWarm : colorCool;\n    vec4 opColor = mix(base, color, 0.1);\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 colorImplicit(Implicit a, vec4 base) {\n    vec4 opColor = mix(base, a.Color, 0.1);\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 colorDerivative(Implicit a, vec4 base) {\n    vec4 opColor = mix(base, mix(colorCool, colorWarm, -a.Distance), 0.1);\n    Implicit wave = TriangleWaveEvenPositive(a, 0.1, a.Color);  \n\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    float clamped = 0.5 - clamp(a.Distance / length(a.Gradient), -0.5, 0.5);\n    return mix(opColor, a.Color, a.Color.a * clamped);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    wobble = readFloat(0.); \n    shapeIndex = int(readFloat(1.) * 3.);\n    \n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + (bounds.w + 20.0) * 3.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    else\n        mouse = shapeIndex == 0 ? vec2(0.0) : vec2(iResolution.x * 0.5, 0.0);\n        \n    if (iMouse.xy == vec2(0.0)) \n        mouse = vec2(0.0);\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    Implicit shape, XPlane, YPlane, shape_x, shape_y, spur;\n    shape = Shape(p, wobble, iResolution.x, iTime, XPlane, YPlane, shape_x, shape_y, spur);\n\n    if (shapeIndex == 0) {\n        opColor = colorImplicit(shape, opColor);\n    } else {\n        shape.Color.a = 0.4;\n        opColor = strokeImplicit(shape, widthThin, opColor);\n        \n        if (shapeIndex == 1){\n            opColor = colorDerivative(shape_x, opColor);\n        } else {\n            opColor = colorDerivative(shape_y, opColor);\n        }\n        \n        opColor = strokeImplicit(Min(XPlane, YPlane), widthThin * 1.2, opColor);  // df on both sides to prevent flutter\n    }\n    \n    \n    // medial axis\n    if (shape.Distance < 0.0) \n        opColor = strokeImplicit(spur, widthThin, opColor);\n    \n    \n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://iquilezles.org/articles/smin/\nImplicit IntersectionExponential(Implicit a, Implicit b, float radius) {\n//    float res = exp2( -a/k ) + exp2( -b/k );\n//    return -k*log2( res );\n\n    a = Exp(Divide(a, radius));\n    b = Exp(Divide(b, radius));\n    Implicit res = Add(a, b);\n    \n    return Multiply(Log(res), radius);\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\n\n\nImplicit RectangleCenterRotatedExp(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    size = size * 0.5;\n    Implicit xPlane = Subtract(Abs(Implicit(centered.x, vec3(1, 0, 0), color)), size.x);\n    Implicit yPlane = Subtract(Abs(Implicit(centered.y, vec3(0, 1, 0), color)), size.y);\n\n\n    \n\treturn IntersectionExponential(xPlane, yPlane, 20.0);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}\n\n\n// Shape\n\nconst vec4 colorWarm = vec4(1., 0., 0., 1);\nconst vec4 colorCool = vec4(0., 0., 1., 1);\nconst vec4 colorBlack = vec4(0, 0, 0, 1);\n\nconst vec3 xDir = vec3(1, 0, 0);    \nconst vec3 yDir = vec3(0, 1, 0);\nconst vec3 zero = vec3(0);\n\nconst float bandWidth = 20.0;\nconst float falloff = 150.0;\nconst float widthThin = 2.0;\nconst float widthThick = 4.0;\n\nconst Implicit Zero = Implicit(0.0, zero, vec4(1, 1, 1, 1));\n\n// The main implicit aka \"map(vec3 p)\".  In common for point sampling.\nImplicit Shape(vec2 p, float wobble, float len, float iTime, \n        out Implicit XPlane, out Implicit YPlane, \n        out Implicit shape_x, out Implicit shape_y, \n        out Implicit spur\n    ) {\n    float halfGolden = 0.5*0.618;\n    vec2 size = len * 0.2 * vec2(1.0 + halfGolden * (1.0 + cos(iTime) * wobble), 1.0) + vec2(140.0 * wobble * cos(iTime * 0.5));\n\n    Implicit shape;\n    vec2 pCenter = abs(p) - size * 0.5;\n    \n    XPlane = Implicit(pCenter.x, xDir, colorWarm);\n    YPlane = Implicit(pCenter.y, yDir, colorCool);\n\n    if (min(pCenter.x, pCenter.y) >= 0.0) {\n        shape = EuclideanNorm(XPlane, YPlane);\n        shape_x = Negate(Divide(XPlane, shape));\n        shape_y = Negate(Divide(YPlane, shape));\n    } else {\n        if (pCenter.x > pCenter.y) {\n            shape = XPlane;\n            shape_x = Implicit(-1.0, zero, YPlane.Color); \n            shape_y = Zero;\n        } else {\n            shape = YPlane;\n            shape_x = Zero;\n            shape_y = Implicit(-1.0, zero, YPlane.Color); \n        }\n    }\n    \n    spur = Implicit(pCenter.x - pCenter.y, vec3(1, -1, 0), vec4(0, 0, 0, 0.4));\n\n    return shape;\n}\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfCircle(vec2 p, float radius) {return length(p) - radius;}\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _R E C T A N G L E _ _R\n    }\n    else if (data.r < 2. * increment) {\n        D _R _ SLASH _ LPAREN D W SLASH _2 RPAREN\n    } else {\n        D _R _ SLASH _ LPAREN D H SLASH _2 RPAREN\n    }\n   \n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n// reading back\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,3)  _S H A P E      \n    EASYSLIDER(0,0.5)  _W O B B L E  \n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    float wobble = readFloat(0.); \n    int shapeIndex = int(readFloat(1.) * 3.);\n\n    Implicit shape, XPlane, YPlane, shape_x, shape_y, spur;\n    vec2 mouseCentered = iMouse.xy - 0.5 * iResolution.xy;\n    shape = Shape(mouseCentered, wobble, iResolution.x, iTime, XPlane, YPlane, shape_x, shape_y, spur);\n    \n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + (bounds.w + 20.0) * 3.0) {\n        float hover;\n        if (shapeIndex == 0) {\n            hover = shape.Distance / bandWidth;\n        } else if (shapeIndex == 1){\n            hover = shape_x.Distance;\n        } else {\n            hover = shape_y.Distance;\n        }\n\n        float centerx = hover >= 10.0 || hover < 0.0 ? 20.0 : 15.0;\n        float mouse = printFloat(hover, 2.0, p, iMouse.xy - vec2(centerx, -widthThick * 2.0));\n        result = mix(result, vec4(UI_COLOR,1), mouse);\n        result = mix(result, vec4(UI_COLOR,1), clamp(-dfCircle(p - iMouse.xy, widthThick), 0.0, 1.0));\n    }\n    \n    fragColor=result;    \n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "43sXRX",
    "date": "1709778083",
    "viewed": 141,
    "name": "LatticeRobot GLSL Output",
    "description": "Example output from LatticeRobot",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "lattice",
     "ugf",
     "latticerobot"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.1\n// This code is example output from LatticeRobot's lattice CodeRep generator.  \n// It is intended for other implicits to use to fill shapes with spatially varying lattices.\n//\n// https://www.latticerobot.com\n//\n// LICENSE: This code is provided under an MIT license.  \n// BETA WARNING: This format will evolve through 2024\n//\n// Documentation:\n// Immediately below, there is a library, followed by the custom code for this parameterized\n// unit cell.  A complier directive replaces the uniforms with internal parameters\n// for the purpose of this Shadertoy demo.\n//\n// Lattice Variants and Index:\n// The latticeIndex uniform accesses the four variants of the lattice F(p), with the shape \n// defined by the preimage of the non-positive values of that variant:\n//\n//   0: Solid. The Solid lattice:\n//       F(p) - bias\n//\n//   1: Inverse. The inverse of the Solid lattice:\n//       -F(p) + bias\n//\n//   2: Thin. A thin band of the Solid lattice:\n//       abs(F(p) - bias) - thickness / 2\n//\n//   3: Twin. The twin axes produced by the inverse of the Thin lattice:\n//       -abs(F(p) - bias) + thickness / 2\n//\n// Common Lattice Parameters (with default value and units):\n//   * size_x, size_y, and size_z (10 mm): The dimensions of the desired bounding box. \n//   * bias (0 mm): The offset of the baseline lattice surface.  Not precise distance.\n//   * thickness (1 mm): Thin and Twin only.  The thickness of the wall of the thin lattice or\n//        the span of the spacing of the twin lattice.  Not precise distance.\n//\n// Special Lattice Parameters (for only this lattice):\n//   * drop_x, drop_y, and drop_z (1): Lattice-specific parameters that attenuate coefficients.\n//   * gyroid (0): interpolates the Diamond TPMS to Gyroid TPMS.  \n//  \n/////////////////////////////////////////////////////////////////////////////////////////////\n\n// Implicit library\n\n#define PI 3.14159265358979\n#define SQRT2 1.41421356237\n#define SQRT3 1.73205080757\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0)); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient);\n}\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance));\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b); }\nImplicit Divide(float a, Implicit b) { return Divide(CreateImplicit(a), b); }\n\nImplicit Min(Implicit a, Implicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Min(Implicit a, float b) { return Min(a, CreateImplicit(b)); }\nImplicit Min(float a, Implicit b) { return Min(CreateImplicit(a), b); }\nImplicit Min(Implicit a, Implicit b, Implicit c) { return Min(a, Min(b, c)); }\nImplicit Min(Implicit a, Implicit b, Implicit c, Implicit d) { return Min(a, Min(b, Min(c, d))); }\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Max(Implicit a, Implicit b, Implicit c) { return Max(a, Max(b, c)); }\nImplicit Max(Implicit a, float b) { return Max(a, CreateImplicit(b)); }\nImplicit Max(float a, Implicit b) { return Max(CreateImplicit(a), b); }\nImplicit Max(Implicit a, Implicit b, Implicit c, Implicit d) { return Max(a, Max(b, Max(c, d))); }\n\nImplicit Compare(Implicit iA, Implicit iB) {\n    if (iA.Distance < iB.Distance)\n        return CreateImplicit(-1.0);\n\n    if (iA.Distance > iB.Distance)\n        return CreateImplicit(1.0);\n\n    return CreateImplicit(0.0);\n}\nImplicit Compare(Implicit iA, float iB) { return Compare(iA, CreateImplicit(iB)); }\nImplicit Compare(float iB, Implicit iA) { return Compare(iA, CreateImplicit(iB)); }\nImplicit Compare(float iA, float iB) { return CreateImplicit(iA == iB ? 0. : (iA > iB ? 1. : -1.)); }\n\nImplicit Conditional(bool condition, Implicit shape1, Implicit shape2) {\n  if (condition)\n    return shape1;\n\n  return shape2;\n}\n\nImplicit Exp(Implicit iImplicit) {\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient);\n}\n\nImplicit Log(Implicit iImplicit) {\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance);\n}\n\nImplicit Pow(Implicit iMantissa, Implicit iExponent) {\n    float result = pow(iMantissa.Distance, iExponent.Distance);\n\treturn Implicit(result, result * log(iMantissa.Distance) * iMantissa.Gradient);\n}\n\nImplicit Sqrt(Implicit iImplicit) {\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt));\n}\n\nImplicit Abs(Implicit iImplicit) {\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Mod(Implicit iImplicit, Implicit iM) {\n\treturn Implicit(mod(iImplicit.Distance, iM.Distance), iImplicit.Gradient);  // TODO fix gradient\n}\nImplicit Mod(Implicit iImplicit, float iM) {\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient);  // TODO fix gradient\n}\n\nImplicit Sin(Implicit iImplicit) {\n\treturn Implicit(sin(iImplicit.Distance), cos(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Cos(Implicit iImplicit) {\n\treturn Implicit(cos(iImplicit.Distance), -sin(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Tan(Implicit iImplicit) {\n    float sec = 1. / cos(iImplicit.Distance);\n\treturn Implicit(tan(iImplicit.Distance), sec * sec * iImplicit.Gradient);\n}\n\nImplicit Asin(Implicit iImplicit) {\n\treturn Implicit(asin(iImplicit.Distance), iImplicit.Gradient / sqrt(1.0 - iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Acos(Implicit iImplicit) {\n\treturn Implicit(acos(iImplicit.Distance), -iImplicit.Gradient / sqrt(1.0 - iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Atan(Implicit iImplicit) {\n\treturn Implicit(atan(iImplicit.Distance), iImplicit.Gradient / (1.0 + iImplicit.Distance * iImplicit.Distance));\n}\n\nImplicit Atan(Implicit a, Implicit b) {  // this version is not correct, but avoids a shading issue.\n    vec3 grad = (b.Distance * a.Gradient - a.Distance * b.Gradient);\n    return Implicit(atan(a.Distance, b.Distance), grad);\n}\n\n// Primitives\n\nImplicit Circle(vec2 p, vec2 center, float iRadius)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0));\n}\n\nmat2 Rotate2D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle) {\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2D(-angle);\n    centered = rot * centered;\n\n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0));\n}\n\nImplicit BoxCenter(vec3 iP, vec3 iCenter, vec3 iSize) {\n\tvec3 p = iP - iCenter;\n\tvec3 b = iSize * 0.5;\n\n\tvec3 d = abs(p)-b;\n\tfloat dist = length(max(d, vec3(0.))) + min(max(d.x, max(d.y, d.z)), 0.);\n\n\tvec3 grad = (d.x > d.y) && (d.x > d.z) ? vec3(1., 0., 0.) :\n\t\t(d.y > d.z ? vec3(0., 1., 0.) : vec3(0., 0., 1.));\n\n\tif (d.x > 0. || d.y > 0. || d.z > 0.)\n\t{\n\t\td = max(d, 0.);\n\t\tgrad = d / length(d);\n\t}\n\n\tgrad *= sign(p);\n\n\treturn Implicit(dist, grad);\n}\n\n// Used by ScaledLattice() \n\nImplicit SphereNative(vec3 iP, vec3 iCenter, float iRadius) {\n\tvec3 centered = iP - iCenter;\n    float length = length(centered);\n\tfloat dist = length - iRadius;\n\treturn Implicit(dist, centered / length);\n}\n\nconst vec3 center = vec3(0.5); \n\n#define STANDALONE 0\nfloat count = 1.00000000;\nfloat size_x = 10.00000000;\nfloat size_y = 10.00000000;\nfloat size_z = 10.00000000;\nfloat bias = 0.00000000;\nfloat thickness = 1.00000000;\nint variantIndex = 2;\n\nvec3 DirX = vec3(1.0, 0.0, 0.0);\nvec3 DirY = vec3(0.0, 1.0, 0.0);\nvec3 DirZ = vec3(0.0, 0.0, 1.0);\n\nfloat Dot(vec3 a, vec3 b) {\n  float _Dot_002 = a.x * b.x + a.y * b.y;\n  return _Dot_002 + a.z * b.z;\n}\n\nImplicit Dot(Implicit a_x, Implicit a_y, Implicit a_z, vec3 b) {\n  Implicit _Dot_000 = Multiply(a_x, b.x);\n  Implicit _Dot_001 = Multiply(a_y, b.y);\n  Implicit _Dot_002 = Add(_Dot_000, _Dot_001);\n  Implicit _Dot_003 = Multiply(a_z, b.z);\n  return Add(_Dot_002, _Dot_003);\n}\n\nImplicit Dot(Implicit a_x, Implicit a_y, Implicit a_z, Implicit b_x, Implicit b_y, Implicit b_z) {\n  Implicit _Dot_000 = Multiply(a_x, b_x);\n  Implicit _Dot_001 = Multiply(a_y, b_y);\n  Implicit _Dot_002 = Add(_Dot_000, _Dot_001);\n  Implicit _Dot_003 = Multiply(a_z, b_z);\n  return Add(_Dot_002, _Dot_003);\n}\n\nfloat Length(vec3 v) {\n  float _Length_000 = Dot(v, v);\n  return sqrt(_Length_000);\n}\n\nImplicit Length(Implicit v_x, Implicit v_y, Implicit v_z) {\n  Implicit _Length_000 = Dot(v_x, v_y, v_z, v_x, v_y, v_z);\n  return Sqrt(_Length_000);\n}\n\nImplicit Clamp(Implicit t, float a, float b) {\n  Implicit _Clamp_000 = Min(t, b);\n  return Max(a, _Clamp_000);\n}\n\nvoid RepeatCentered(Implicit p_x, Implicit p_y, Implicit p_z, vec3 period, out Implicit RepeatCentered_x, out Implicit RepeatCentered_y, out Implicit RepeatCentered_z) {\n  vec3 halfPeriod = period * 0.5;\n  Implicit _RepeatCentered_000_x = Add(p_x, halfPeriod.x);\n  Implicit _RepeatCentered_001_x = Mod(_RepeatCentered_000_x, period.x);\n  Implicit _RepeatCentered_002_x = Subtract(_RepeatCentered_001_x, halfPeriod.x);\n  Implicit _RepeatCentered_000_y = Add(p_y, halfPeriod.y);\n  Implicit _RepeatCentered_001_y = Mod(_RepeatCentered_000_y, period.y);\n  Implicit _RepeatCentered_002_y = Subtract(_RepeatCentered_001_y, halfPeriod.y);\n  Implicit _RepeatCentered_000_z = Add(p_z, halfPeriod.z);\n  Implicit _RepeatCentered_001_z = Mod(_RepeatCentered_000_z, period.z);\n  Implicit _RepeatCentered_002_z = Subtract(_RepeatCentered_001_z, halfPeriod.z);\n  RepeatCentered_x = _RepeatCentered_002_x;\n  RepeatCentered_y = _RepeatCentered_002_y;\n  RepeatCentered_z = _RepeatCentered_002_z;\n}\n\nImplicit IntersectSharp3(Implicit a, Implicit b, Implicit c) {\n  Implicit _IntersectSharp3_000 = Max(a, b);\n  return Max(_IntersectSharp3_000, c);\n}\n\nImplicit Sphere(vec3 p, vec3 center, float radius) {\n  vec3 c = p - center;\n  float len = Length(c);\n  float dist = len - radius;\n  vec3 _Sphere_000 = c / len;\n  return Implicit(dist, _Sphere_000);\n}\n\nImplicit LineSegment(Implicit p_x, Implicit p_y, Implicit p_z, vec3 a, vec3 b) {\n  Implicit pa_x = Subtract(p_x, a.x);\n  Implicit pa_y = Subtract(p_y, a.y);\n  Implicit pa_z = Subtract(p_z, a.z);\n  vec3 ba = b - a;\n  Implicit _h_003 = Dot(pa_x, pa_y, pa_z, ba);\n  float _h_004 = Dot(ba, ba);\n  Implicit _h_005 = Divide(_h_003, _h_004);\n  Implicit h = Clamp(_h_005, 0.0, 1.0);\n  vec3 _LineSegment_002 = ba * h.Distance;\n  Implicit _LineSegment_003_x = Subtract(pa_x, _LineSegment_002.x);\n  Implicit _LineSegment_003_y = Subtract(pa_y, _LineSegment_002.y);\n  Implicit _LineSegment_003_z = Subtract(pa_z, _LineSegment_002.z);\n  return Length(_LineSegment_003_x, _LineSegment_003_y, _LineSegment_003_z);\n}\n\nImplicit LineSegmentRepeatMirror(Implicit p_x, Implicit p_y, Implicit p_z, vec3 a, vec3 b, vec3 size) {\n  Implicit _mod_out_000_x;\n  Implicit _mod_out_000_y;\n  Implicit _mod_out_000_z;\n  RepeatCentered(p_x, p_y, p_z, size, _mod_out_000_x, _mod_out_000_y, _mod_out_000_z);\n  Implicit mod_x = Abs(_mod_out_000_x);\n  Implicit mod_y = Abs(_mod_out_000_y);\n  Implicit mod_z = Abs(_mod_out_000_z);\n  return LineSegment(mod_x, mod_y, mod_z, a, b);\n}\n\nImplicit BoxCenteredSharp(Implicit p_x, Implicit p_y, Implicit p_z, vec3 center, vec3 size) {\n  Implicit _planes_000_x = Subtract(p_x, center.x);\n  Implicit _planes_001_x = Abs(_planes_000_x);\n  vec3 _planes_002 = size * 0.5;\n  Implicit planes_x = Subtract(_planes_001_x, _planes_002.x);\n  Implicit _planes_000_y = Subtract(p_y, center.y);\n  Implicit _planes_001_y = Abs(_planes_000_y);\n  Implicit planes_y = Subtract(_planes_001_y, _planes_002.y);\n  Implicit _planes_000_z = Subtract(p_z, center.z);\n  Implicit _planes_001_z = Abs(_planes_000_z);\n  Implicit planes_z = Subtract(_planes_001_z, _planes_002.z);\n  return IntersectSharp3(planes_x, planes_y, planes_z);\n}\n\nImplicit indexedLattice(vec3 p, int index, out Implicit solid) {\n  vec3 size = vec3(size_x, size_y, size_z);\n  vec3 halfsize = size * 0.5;\n  vec3 _beam0_002 = vec3(0.0, halfsize.y, 0.0);\n  vec3 _beam0_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit p_x = Implicit(p.x, DirX);\n  Implicit p_y = Implicit(p.y, DirY);\n  Implicit p_z = Implicit(p.z, DirZ);\n  Implicit beam0 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam0_002, _beam0_003, size);\n  vec3 _beam1_002 = vec3(halfsize.x, 0.0, 0.0);\n  vec3 _beam1_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit _beam1_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam1_002, _beam1_003, size);\n  Implicit beam1 = Min(beam0, _beam1_004);\n  vec3 _beam2_002 = vec3(halfsize.x, 0.0, 0.0);\n  vec3 _beam2_003 = vec3(0.0, halfsize.y, 0.0);\n  Implicit _beam2_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam2_002, _beam2_003, size);\n  Implicit beam2 = Min(beam1, _beam2_004);\n  vec3 _beam3_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beam3_003 = vec3(0.0, 0.0, halfsize.z);\n  Implicit _beam3_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam3_002, _beam3_003, size);\n  Implicit beam3 = Min(beam2, _beam3_004);\n  vec3 _beam4_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beam4_003 = vec3(0.0, halfsize.y, 0.0);\n  Implicit _beam4_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beam4_002, _beam4_003, size);\n  Implicit beam4 = Min(beam3, _beam4_004);\n  vec3 _beams_002 = vec3(halfsize.x, halfsize.y, halfsize.z);\n  vec3 _beams_003 = vec3(halfsize.x, 0.0, 0.0);\n  Implicit _beams_004 = LineSegmentRepeatMirror(p_x, p_y, p_z, _beams_002, _beams_003, size);\n  Implicit beams = Min(beam4, _beams_004);\n  Implicit lattice = Subtract(beams, bias);\n  solid = lattice;\n  if (index == 0) return solid;\n  Implicit inverse = Multiply(-1.0, lattice);\n  if (index == 1) return inverse;\n  Implicit _thin_000 = Abs(lattice);\n  Implicit thin = Subtract(_thin_000, thickness * 0.5);\n  if (index == 2) return thin;\n  Implicit twin = Multiply(-1.0, thin);\n  if (index == 3) return twin;\n  return Sphere(p, vec3(0.0), 0.5);\n}\n\nImplicit scaledLattice(vec3 scaledP, int index, out Implicit scaledBase) {\n  vec3 p = (scaledP - center) * 10.0;\n  Implicit base;\n  Implicit indexed = indexedLattice(p, index, base);\n  scaledBase = Divide(base, 10.0);\n  return Divide(indexed, 10.0);\n}\n\n\n// Implicit API not used by GCLS (mostly unused in LR)\n\nImplicit Square(Implicit iImplicit) {\n\tfloat square = iImplicit.Distance * iImplicit.Distance ;\n\treturn Implicit(square, 2. *  square * iImplicit.Gradient);\n}\n\nvec3 Boundary(vec3 iP, Implicit i) {\n    return -i.Distance * i.Gradient;\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) {\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k, out float param) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    param = h2.Distance;\n    param = iA.Distance < iB.Distance ? param : (1.0 - param);\n\n    return result;\n}\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k) {\n    float param;\n    return UnionChamfer(iA, iB, k, param);\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k, out float param)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    param = 0.5 + 0.5 * (iA.Distance - iB.Distance) / (iA.Distance + iB.Distance);\n\n    return result;\n}\nImplicit UnionRound(Implicit iA, Implicit iB, float k) {\n    float param;\n    return UnionRound(iA, iB, k, param);\n}\n\n\nImplicit PlaneNative(vec3 p, vec3 origin, vec3 normal)\n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad);\n}\nImplicit PlaneNative(vec2 p, vec2 origin, vec2 normal)\n{\n    return PlaneNative(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, -sa * p.y + ca * p.z, ca * p.y + sa * p.z);\n}\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\n// ColorImplicit\n\nstruct ColorImplicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nColorImplicit CreateColorImplicit(Implicit implicit, vec4 color) {\n    return ColorImplicit(implicit.Distance, implicit.Gradient, color);\n}\nColorImplicit CreateColorImplicit(float distance, vec4 color) {\n    return CreateColorImplicit(CreateImplicit(distance), color);\n}\n\nColorImplicit Min(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\nColorImplicit Max(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\nColorImplicit Add(ColorImplicit a, ColorImplicit b) {\n\treturn ColorImplicit(\n        a.Distance + b.Distance,\n        a.Gradient + b.Gradient,\n        0.5 * (a.Color + b.Color)\n    );\n}\nColorImplicit Add(ColorImplicit a, float b) { return CreateColorImplicit(Add(Implicit(a.Distance, a.Gradient), b), a.Color); }\n\nColorImplicit Subtract(ColorImplicit a, ColorImplicit b) {\n\treturn ColorImplicit(\n        a.Distance - b.Distance,\n        a.Gradient - b.Gradient,\n        0.5 * (a.Color + b.Color)\n    );\n}\nColorImplicit Subtract(ColorImplicit a, float b) { return CreateColorImplicit(Subtract(Implicit(a.Distance, a.Gradient), b), a.Color); }\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot Renderer v0.1\n//\n// This renderer is similar to the one used by LatticeRobot, derived from IQ and related ShaderToys as commented below.  \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#if STANDALONE\n\n// Renderer uniforms\n\nuniform vec2 resolution;\nuniform float time;\nuniform float fov;\nuniform vec3 camera;\nuniform float count;\n\n// LatticeRobot uniforms\n\nuniform vec3 color_primary;\nuniform vec3 color_secondary;\nuniform vec3 color_boundingbox;\nuniform vec3 color_background;\n\n#else \n\nconst float cHigh = 0.8;\nconst float cMed = 0.7;\nconst float cLow = 0.3;\nconst vec3 color_primary = vec3(cMed, cMed, cHigh);\nconst vec3 color_secondary = vec3(cHigh, cMed, cMed);\nconst vec3 color_boundingbox = vec3(cHigh, cHigh, cHigh);\nconst vec3 color_background = vec3(1.0, 1.0, 1.0);\n\n#endif\n\n// Tree root\nColorImplicit map(vec3 p) {\n#if (STANDALONE==0)\n\n    float time = iTime;\n    vec2 resolution = iResolution.xy;\n\n#endif\n\n    vec4 colorCool = vec4(color_primary, 1.0);\n    vec4 colorWarm = vec4(color_secondary, 1.0);\n    vec4 colorLightGray = vec4(color_boundingbox, 1.0);\n\n    float amp = 0.05;\n    vec3 pOrig = p * vec3(1. + amp * cos(time), 1. + amp * cos(time), 1. + amp * sin(time));  // play with size\n    p = pOrig * count + center;\n\n    Implicit base;\n    ColorImplicit merged = CreateColorImplicit(Divide(scaledLattice(p, variantIndex, base), count), colorLightGray);\n    ColorImplicit bounds = CreateColorImplicit(BoxCenter(pOrig + center, center, 0.1 * vec3(size_x, size_y, size_z)), colorLightGray);\n\n    float bumpOffset = 0.05;\n    float bump = pow(abs(cos((1.5 * time + p.z) * 0.4)), 400.);\n    ColorImplicit colorField = Add(merged, -bump * bumpOffset);\n\n    vec4 baseColor = variantIndex == 1 ? colorWarm : colorCool;\n    colorField.Color = baseColor;\n    if (variantIndex > 1) {\n        colorField.Color = (base.Distance > 0.0) ? colorCool : colorWarm;\n    }\n\n    colorField.Color = colorField.Color + vec4(bump * 0.2);\n    return Max(colorField, bounds);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map(pos + e.xyy*eps).Distance +\n\t\t\t\t\t  e.yyx*map(pos + e.yyx*eps).Distance +\n\t\t\t\t\t  e.yxy*map(pos + e.yxy*eps).Distance +\n\t\t\t\t\t  e.xxx*map(pos + e.xxx*eps).Distance );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadowBanding( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).Distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ ) {\n        float h = map(ro + t*rd).Distance;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// advanced via https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ ) {\n\t\tfloat h = map( ro + rd*t ).Distance;\n\n        // traditional technique\n        if( technique==0 ) {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n\n            // float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).Distance;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n// IQ rendering https://www.shadertoy.com/view/wlXSD7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if (STANDALONE==0)\n\n    float time = iTime;\n    vec2 resolution = iResolution.xy;\n\n#endif\n    vec2 p = (-resolution.xy + 2.0*fragCoord)/resolution.y;\n\n    float rad = 1.25;\n    float lightAng = 0.0;\n\tvec3 ro = vec3( rad*cos(lightAng), rad*sin(lightAng), 0.7 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    // camera movement\n\tfloat an = 0.125*(time-10.0);\n    mat3 rot = RotateZ(an);\n    mat3 rotInv = RotateZ(-an);\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.5;\n    float t = 0.0;\n    ColorImplicit hit;\n    for( int i=0; i<256; i++ ) {\n        vec3 pos = (ro + t*rd) * rot;\n        hit = map(pos);\n        if( hit.Distance < 0.0001 || t > tmax ) break;\n        t += hit.Distance * 0.45;  // slow down to not miss sharp features and TPMS with Lipschitz > 1.  \n    }\n\n    if (t > tmax)\n        tot = vec3(1.0);\n        vec3 nor;\n\n#if 0    // 1 for simple renderer\n    // shading/lighting\n    vec3 col = color_background;\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        //vec3 nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n\n        float dif = clamp( dot(nor, vec3(0.8, 0., 0.6) * rot ), 0.0, 1.0 );\n        float amb = 0.5 ;\n        col = vec3(0.6)*amb + vec3(1.)*dif;\n        col = col * hit.Color.rgb;\n    }\n#else\n    // shading/lighting\n    vec3 col = color_background;\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        // nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n        vec3 lig = normalize(vec3(0.6,0.0,0.4)) * rot;\n        vec3 hal = normalize(lig-rd*rot);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float occ = calcOcclusion( pos, nor );\n        if( dif>0.001 ) dif *= softshadow( pos, lig, 0.0001, 1.0, 0.2 );\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd*rot),0.0,1.0),5.0));\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.0,1.0));\n        col =  hit.Color.rgb * amb*occ;\n        col += hit.Color.rgb * dif * 0.8;\n\n        col *= 0.8;\n\n        col += vec3(1.,1.,1.)*spe*2.0;\n    }\n#endif\n\n    tot += col;\n\tfragColor = vec4( tot, 1.0 );\n}\n\n#if STANDALONE\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    gl_FragColor = vec4( 1. );\n\n    mainImage(gl_FragColor, fragCoord);\n}\n\n#endif\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gradient Control Laboratories</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #fff;
        }

        #container {
            width: 100%;
            height: 100%;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Person link hover: color shift instead of underline */
        .person-link {
            text-decoration: none;
        }

        .person-link text {
            transition: fill 0.2s ease;
        }

        .person-link:hover text {
            fill: #0057b8 !important;
        }

        .person-link:hover .person-bg {
            fill: #eef4ff !important;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        (function () {
            //
            // Category definitions and colors
            //
            const categories = {
                "Software": { color: "#f5e8c0", border: "#d8c898" },
                "Hardware": { color: "#c9e8c9", border: "#9bca9b" },
                "CAD": { color: "#c5d5ea", border: "#9bb5d4" },
                "Academia": { color: "#f2c8d4", border: "#d4a0b0" },
                "Collective": { color: "#d8c8e8", border: "#b8a0d0" }
            };

            const originColor = "#c8c0e0";
            const originBorder = "#a098c0";

            //
            // People URLs from NSF Tech Labs RFI Response
            //
            const personUrls = {
                "Blake Courter": "https://www.blakecourter.com/",
                "Luke Church, PhD": "https://www.linkedin.com/in/lukechurch/",
                "Dan Rubel": "https://www.linkedin.com/in/danrubel/",
                "Steve DeMai": "https://www.linkedin.com/in/stephen-demai-a5ba2b4/",
                "Keegan McNamara": "https://www.linkedin.com/in/keeganmcnamara/",
                "Mariana Marasoiu, PhD": "https://www.linkedin.com/in/marianamarasoiu/"
            };

            //
            // Node data — positions estimated from reference layout
            //
            const nodes = [
                // Origin
                { id: "Gradient Control Laboratories", type: "origin", ix: 0, iy: 0 },

                // People
                { id: "Blake Courter", type: "person", ix: -200, iy: -215 },
                { id: "Luke Church, PhD", type: "person", ix: 205, iy: -240 },
                { id: "Dan Rubel", type: "person", ix: 290, iy: -35 },
                { id: "Steve DeMai", type: "person", ix: -290, iy: 100 },
                { id: "Keegan McNamara", type: "person", ix: -170, iy: 250 },
                { id: "Robert Iannuzzo", type: "person", ix: 30, iy: 265 },
                { id: "Emma Brennan", type: "person", ix: 190, iy: 120 },
                { id: "Mariana Marasoiu, PhD", type: "person", ix: 500, iy: 210 },

                // Organizations
                { id: "PTC", type: "org", category: "CAD", ix: -520, iy: -295 },
                { id: "FluidForm", type: "org", category: "Hardware", ix: -360, iy: -280 },
                { id: "SpaceClaim", type: "org", category: "CAD", ix: -490, iy: -180 },
                { id: "ANSYS", type: "org", category: "CAD", ix: -400, iy: -230 },
                { id: "nTop", type: "org", category: "CAD", ix: -140, iy: -295 },
                { id: "Autodesk", type: "org", category: "CAD", ix: -10, iy: -265 },
                { id: "GrabCAD", type: "org", category: "CAD", ix: -370, iy: -140 },
                { id: "Stratasys", type: "org", category: "Hardware", ix: -505, iy: -30 },
                { id: "Vibe Robotics", type: "org", category: "CAD", ix: 290, iy: -290 },
                { id: "Thales", type: "org", category: "CAD", ix: 390, iy: -285 },
                { id: "Cambridge University", type: "org", category: "Academia", ix: 640, iy: -265 },
                { id: "ConstructivIQ", type: "org", category: "CAD", ix: 360, iy: -165 },
                { id: "Lark Systems", type: "org", category: "Collective", ix: 170, iy: -60 },
                { id: "Instantiations", type: "org", category: "Software", ix: 600, iy: -120 },
                { id: "Google", type: "org", category: "Software", ix: 420, iy: 0 },
                { id: "Eclipse", type: "org", category: "Software", ix: 610, iy: 30 },
                { id: "SolidWorks", type: "org", category: "CAD", ix: -380, iy: 70 },
                { id: "Avid", type: "org", category: "Hardware", ix: -520, iy: 75 },
                { id: "Mythic", type: "org", category: "Hardware", ix: -210, iy: 65 },
                { id: "Comcast", type: "org", category: "Hardware", ix: 190, iy: 230 },
                { id: "Arkham", type: "org", category: "Software", ix: -120, iy: 185 },
                { id: "VC", type: "org", category: "Collective", ix: -230, iy: 240 },
                { id: "AWS", type: "org", category: "Software", ix: -360, iy: 265 },
                { id: "NATION", type: "org", category: "Software", ix: -125, iy: 250 },
                { id: "PPIG", type: "org", category: "Academia", ix: 610, iy: 245 }
            ];

            // Initialize simulation positions from compact coordinates
            nodes.forEach(n => { n.x = n.ix; n.y = n.iy; });

            // Build node map for quick lookup
            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            //
            // Link data
            //
            const people = [
                "Blake Courter", "Luke Church, PhD", "Dan Rubel", "Steve DeMai",
                "Keegan McNamara", "Robert Iannuzzo", "Emma Brennan", "Mariana Marasoiu, PhD"
            ];

            const links = [
                // All people connect to GCL
                ...people.map(p => ({
                    source: p,
                    target: "Gradient Control Laboratories",
                    linkType: "person-origin"
                })),

                // Blake Courter
                { source: "Blake Courter", target: "PTC" },
                { source: "Blake Courter", target: "SpaceClaim" },
                { source: "Blake Courter", target: "nTop" },
                { source: "Blake Courter", target: "GrabCAD" },
                { source: "Blake Courter", target: "Stratasys" },
                { source: "Blake Courter", target: "FluidForm" },

                // Luke Church, PhD
                { source: "Luke Church, PhD", target: "Autodesk" },
                { source: "Luke Church, PhD", target: "Thales" },
                { source: "Luke Church, PhD", target: "Vibe Robotics" },
                { source: "Luke Church, PhD", target: "Google" },
                { source: "Luke Church, PhD", target: "Lark Systems" },
                { source: "Luke Church, PhD", target: "Cambridge University" },
                { source: "Luke Church, PhD", target: "ConstructivIQ" },
                { source: "Luke Church, PhD", target: "PPIG" },

                // Dan Rubel
                { source: "Dan Rubel", target: "Eclipse" },
                { source: "Dan Rubel", target: "Lark Systems" },
                { source: "Dan Rubel", target: "Google" },
                { source: "Dan Rubel", target: "Instantiations" },

                // Steve DeMai
                { source: "Steve DeMai", target: "SolidWorks" },
                { source: "Steve DeMai", target: "Avid" },
                { source: "Steve DeMai", target: "GrabCAD" },
                { source: "Steve DeMai", target: "Stratasys" },

                // Keegan McNamara
                { source: "Keegan McNamara", target: "AWS" },
                { source: "Keegan McNamara", target: "VC" },
                { source: "Keegan McNamara", target: "Arkham" },
                { source: "Keegan McNamara", target: "Mythic" },
                { source: "Keegan McNamara", target: "NATION" },

                // Emma Brennan
                { source: "Emma Brennan", target: "Lark Systems" },
                { source: "Emma Brennan", target: "Comcast" },
                { source: "Emma Brennan", target: "Vibe Robotics" },

                // Mariana Marasoiu, PhD
                { source: "Mariana Marasoiu, PhD", target: "Cambridge University" },
                { source: "Mariana Marasoiu, PhD", target: "PPIG" },
                { source: "Mariana Marasoiu, PhD", target: "Google" },
                { source: "Mariana Marasoiu, PhD", target: "Lark Systems" },

                // Acquisitions (source was acquired by target)
                { source: "GrabCAD", target: "Stratasys", linkType: "acquisition" },
                { source: "Instantiations", target: "Google", linkType: "acquisition" },
                { source: "Lark Systems", target: "Gradient Control Laboratories", linkType: "acquisition" },
                { source: "SpaceClaim", target: "ANSYS", linkType: "acquisition" }
            ];

            //
            // Layout constants — scaled ~1.25x from original
            //
            const orgFontSize = 18;
            const personFontSize = 22;
            const originFontSize = 35;
            const padX = 18;
            const padY = 10;
            const lineHeight = 22;

            function getLines(d) {
                if (d.type === "origin") return ["Gradient", "Control", "Laboratories"];
                if (d.type === "person") return [d.id];
                return d.id.split(" ");
            }

            function getNodeWidth(d) {
                if (d.type === "origin") return 275;
                const lines = getLines(d);
                const fs = d.type === "person" ? personFontSize : orgFontSize;
                const cw = fs * 0.58;
                const maxLen = Math.max(...lines.map(l => l.length));
                if (d.type === "person") return maxLen * cw + 16;
                return maxLen * cw + padX * 2;
            }

            function getNodeHeight(d) {
                if (d.type === "origin") return 188;
                if (d.type === "person") return personFontSize + 10;
                const lines = getLines(d);
                return lines.length * lineHeight + padY * 2;
            }

            function getCollisionRadius(d) {
                if (d.type === "origin") return 150;
                const w = getNodeWidth(d) / 2;
                const h = getNodeHeight(d) / 2;
                return Math.sqrt(w * w + h * h) + 6;
            }

            //
            // SVG setup — virtual viewport scales down on small screens
            //
            const container = document.getElementById("container");
            let width = container.clientWidth;
            let height = container.clientHeight;

            const sizeThreshold = 600;
            function computeVirtual(w, h) {
                const minDim = Math.min(w, h);
                const scale = minDim >= sizeThreshold ? 1 : minDim / sizeThreshold;
                return { vw: w / scale, vh: h / scale };
            }
            let { vw, vh } = computeVirtual(width, height);

            const svg = d3.select("#container")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [-vw / 2, -vh / 2, vw, vh]);

            // Arrow marker for acquisition links (centered at midpoint)
            svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 0 10 6")
                .attr("refX", 5)
                .attr("refY", 3)
                .attr("markerWidth", 10)
                .attr("markerHeight", 7)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,0 L10,3 L0,6 Z")
                .attr("fill", "#999");

            //
            // Legend — draggable, repels nodes, not affected by forces
            //
            const legendPadding = 12;
            const legendItemH = 28;
            const legendSwatchW = 22;
            const legendSwatchH = 17;
            const legendEntries = Object.entries(categories);
            const legendH = (legendEntries.length + 1) * legendItemH + legendPadding * 2;
            const legendW = 120;
            const legendTotalW = legendW + legendPadding * 2;
            const legendTotalH = legendH;

            // Legend position in SVG coordinates (bottom-left)
            // Edge gap matches org half-height padding (~21px)
            const legendEdgePad = 21;
            const legendPos = {
                x: -vw / 2 + legendEdgePad + legendPadding,
                y: vh / 2 - legendTotalH - legendEdgePad + legendPadding
            };

            // Bounding box of the legend in SVG coords
            const legendBox = { x: 0, y: 0, w: legendTotalW, h: legendTotalH };

            function updateLegendBox() {
                legendBox.x = legendPos.x - legendPadding;
                legendBox.y = legendPos.y - legendPadding;
            }
            updateLegendBox();

            //
            // Custom boundary repulsion force — uses container div dimensions
            //
            function forceBoundary() {
                let simNodes;
                let boundW = vw, boundH = vh;
                const padding = 10;
                const strength = 1.2;

                function force(alpha) {
                    const s = Math.max(alpha, 0.1) * strength;
                    for (const d of simNodes) {
                        const r = getCollisionRadius(d);
                        const left = -boundW / 2 + padding + r;
                        const right = boundW / 2 - padding - r;
                        const top = -boundH / 2 + padding + r;
                        const bottom = boundH / 2 - padding - r;

                        if (d.x < left) d.vx += (left - d.x) * s;
                        if (d.x > right) d.vx += (right - d.x) * s;
                        if (d.y < top) d.vy += (top - d.y) * s;
                        if (d.y > bottom) d.vy += (bottom - d.y) * s;
                    }
                }

                force.initialize = function (_) { simNodes = _; };
                force.resize = function (w, h) { boundW = w; boundH = h; return force; };
                return force;
            }

            const boundary = forceBoundary();

            //
            // Legend repulsion force — pushes nodes away from legend rectangle
            //
            function forceLegendRepel() {
                let simNodes;

                function force(alpha) {
                    const s = Math.max(alpha, 0.15) * 4.0;
                    const lcx = legendBox.x + legendBox.w / 2;
                    const lcy = legendBox.y + legendBox.h / 2;

                    for (const d of simNodes) {
                        const r = getCollisionRadius(d);
                        const dx = d.x - lcx;
                        const dy = d.y - lcy;
                        const halfW = legendBox.w / 2 + r + 5;
                        const halfH = legendBox.h / 2 + r + 5;

                        if (Math.abs(dx) < halfW && Math.abs(dy) < halfH) {
                            const overlapX = halfW - Math.abs(dx);
                            const overlapY = halfH - Math.abs(dy);
                            if (overlapX < overlapY) {
                                d.vx += Math.sign(dx || 1) * overlapX * s;
                            } else {
                                d.vy += Math.sign(dy || 1) * overlapY * s;
                            }
                        }
                    }
                }

                force.initialize = function (_) { simNodes = _; };
                return force;
            }

            //
            // Force simulation
            //
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .strength(d => {
                        if (d.linkType === "acquisition") return 0.8;
                        if (d.linkType === "person-origin") return 0.025;
                        return 0; // person-org handled by custom max-metric force
                    })
                    .distance(d => {
                        if (d.linkType === "acquisition") {
                            // Target distance ≈ current settled length (sum of collision radii)
                            const sr = getCollisionRadius(nodeMap[d.source.id || d.source]);
                            const tr = getCollisionRadius(nodeMap[d.target.id || d.target]);
                            return sr + tr;
                        }
                        if (d.linkType === "person-origin") return 180;
                        return 130;
                    }))
                .force("charge", d3.forceManyBody().strength(-150))
                .force("collide", d3.forceCollide(d => getCollisionRadius(d)).strength(0.9))
                .force("x", d3.forceX(d => d.ix).strength(0.15))
                .force("y", d3.forceY(d => d.iy).strength(0.15))
                .force("boundary", boundary)
                .force("legendRepel", forceLegendRepel());

            // Custom max-metric (Chebyshev) force for person-org links
            // dist = max(|dx|, |dy|) so horizontal spread doesn't fight the link
            const personOrgLinkData = links.filter(l => !l.linkType);
            simulation.force("personOrgMax", function () {
                function force(alpha) {
                    const s = alpha * 0.025;
                    for (const l of personOrgLinkData) {
                        const dx = l.target.x - l.source.x;
                        const dy = l.target.y - l.source.y;
                        const dist = Math.max(Math.abs(dx), Math.abs(dy)) || 1;
                        const delta = (dist - 130) / dist * s;
                        const fx = dx * delta;
                        const fy = dy * delta;
                        l.source.vx += fx;
                        l.target.vx -= fx;
                        l.source.vy += fy;
                        l.target.vy -= fy;
                    }
                }
                force.initialize = function () { };
                return force;
            }());

            //
            // Separate regular links from acquisition links for rendering
            //
            const regularLinkData = links.filter(l => l.linkType !== "acquisition");
            const acquisitionLinkData = links.filter(l => l.linkType === "acquisition");

            // Render regular links
            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(regularLinkData)
                .join("line")
                .attr("stroke", "#b8b8b8")
                .attr("stroke-width", d => d.linkType === "person-origin" ? 2.5 : 1.5)
                .attr("stroke-opacity", 0.5);

            // Render acquisition arrows — thick center-to-center with midpoint arrowhead
            const acqLink = svg.append("g")
                .attr("class", "acquisition-links")
                .selectAll("path")
                .data(acquisitionLinkData)
                .join("path")
                .attr("stroke", "#999")
                .attr("stroke-width", 2.5)
                .attr("stroke-opacity", 0.5)
                .attr("fill", "none")
                .attr("marker-mid", "url(#arrow)");

            //
            // Render nodes
            //
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .join("g")
                .style("cursor", "grab")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // --- Origin node: large ellipse ---
            const originNode = node.filter(d => d.type === "origin");

            originNode.append("ellipse")
                .attr("rx", 144)
                .attr("ry", 100)
                .attr("fill", originColor)
                .attr("stroke", originBorder)
                .attr("stroke-width", 2.5)
                .attr("opacity", 0.75);

            const originText = originNode.append("text")
                .attr("text-anchor", "middle")
                .attr("font-size", `${originFontSize}px`)
                .attr("font-weight", "bold")
                .attr("fill", "#333");

            originText.selectAll("tspan")
                .data(d => getLines(d))
                .join("tspan")
                .attr("x", 0)
                .attr("y", (d, i, nodes) => `${(i - (nodes.length - 1) / 2) * 1.25}em`)
                .text(d => d);

            // --- Organization nodes: rounded rectangles ---
            const orgNodes = node.filter(d => d.type === "org");

            orgNodes.append("rect")
                .attr("x", d => -getNodeWidth(d) / 2)
                .attr("y", d => -getNodeHeight(d) / 2)
                .attr("width", d => getNodeWidth(d))
                .attr("height", d => getNodeHeight(d))
                .attr("rx", 7)
                .attr("ry", 7)
                .attr("fill", d => categories[d.category].color)
                .attr("stroke", d => categories[d.category].border)
                .attr("stroke-width", 1.5);

            const orgText = orgNodes.append("text")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "central")
                .attr("font-size", `${orgFontSize}px`)
                .attr("fill", "#333");

            orgText.selectAll("tspan")
                .data(d => getLines(d))
                .join("tspan")
                .attr("x", 0)
                .attr("y", (d, i, nodes) => `${(i - (nodes.length - 1) / 2) * 1.2}em`)
                .text(d => d);

            // --- Person nodes: bold text with white background and optional link ---
            const personNodes = node.filter(d => d.type === "person");

            personNodes.each(function (d) {
                const g = d3.select(this);
                const url = personUrls[d.id];
                const wrapper = url
                    ? g.append("a")
                        .attr("href", url)
                        .attr("target", "_blank")
                        .attr("class", "person-link")
                    : g;

                const w = getNodeWidth(d);
                const h = getNodeHeight(d);
                wrapper.append("rect")
                    .attr("class", "person-bg")
                    .attr("x", -w / 2)
                    .attr("y", -h / 2)
                    .attr("width", w)
                    .attr("height", h)
                    .attr("rx", 4)
                    .attr("ry", 4)
                    .attr("fill", "white")
                    .attr("opacity", 0.9);

                wrapper.append("text")
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .attr("font-size", `${personFontSize}px`)
                    .attr("font-weight", "bold")
                    .attr("fill", "#222")
                    .style("pointer-events", "none")
                    .text(d.id);
            });

            //
            // Legend — rendered last so it draws on top
            //
            const legend = svg.append("g")
                .style("cursor", "grab");

            legend.attr("transform", `translate(${legendPos.x}, ${legendPos.y})`);

            legend.append("rect")
                .attr("x", -legendPadding)
                .attr("y", -legendPadding)
                .attr("width", legendTotalW)
                .attr("height", legendTotalH)
                .attr("rx", 8)
                .attr("ry", 8)
                .attr("fill", "white")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1);

            const legendItem = legend.selectAll(".legend-item")
                .data(legendEntries)
                .join("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * legendItemH})`);

            legendItem.append("rect")
                .attr("width", legendSwatchW)
                .attr("height", legendSwatchH)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", d => d[1].color)
                .attr("stroke", d => d[1].border)
                .attr("stroke-width", 1);

            legendItem.append("text")
                .attr("x", legendSwatchW + 8)
                .attr("y", legendSwatchH / 2)
                .attr("dominant-baseline", "central")
                .attr("font-size", "14px")
                .attr("fill", "#444")
                .text(d => d[0]);

            // "Exit" legend item — arrow triangle as key
            const exitItem = legend.append("g")
                .attr("transform", `translate(0, ${legendEntries.length * legendItemH})`);
            exitItem.append("path")
                .attr("d", `M2,1 L${legendSwatchW - 2},${legendSwatchH / 2} L2,${legendSwatchH - 1} Z`)
                .attr("fill", "#999");
            exitItem.append("text")
                .attr("x", legendSwatchW + 8)
                .attr("y", legendSwatchH / 2)
                .attr("dominant-baseline", "central")
                .attr("font-size", "14px")
                .attr("fill", "#444")
                .text("Exit");

            // Legend drag — moves legend, does NOT affect simulation nodes
            legend.call(d3.drag()
                .on("start", function () {
                    d3.select(this).style("cursor", "grabbing");
                })
                .on("drag", function (event) {
                    legendPos.x += event.dx;
                    legendPos.y += event.dy;
                    legend.attr("transform", `translate(${legendPos.x}, ${legendPos.y})`);
                    updateLegendBox();
                    simulation.alpha(0.3).restart();
                })
                .on("end", function () {
                    d3.select(this).style("cursor", "grab");
                }));

            //
            // Simulation tick — boundary clamping + overlap separation
            //
            const orgList = nodes.filter(n => n.type === "org");
            const personList = nodes.filter(n => n.type === "person");
            const originNode_ = nodes.find(n => n.type === "origin");
            let draggedNode = null;

            simulation.on("tick", () => {
                // Hard clamp to virtual container bounds
                const pad = 10;
                nodes.forEach(d => {
                    const r = getCollisionRadius(d);
                    d.x = Math.max(-vw / 2 + pad + r, Math.min(vw / 2 - pad - r, d.x));
                    d.y = Math.max(-vh / 2 + pad + r, Math.min(vh / 2 - pad - r, d.y));
                });

                // Hard rectangular separation for org nodes — equal padding, biased toward side-by-side
                for (let i = 0; i < orgList.length; i++) {
                    for (let j = i + 1; j < orgList.length; j++) {
                        const a = orgList[i], b = orgList[j];
                        if (a === draggedNode || b === draggedNode) continue;
                        const ha = getNodeHeight(a), hb = getNodeHeight(b);
                        const padH = (ha + hb) / 4; // half average height
                        const reqDx = (getNodeWidth(a) + getNodeWidth(b)) / 2 + padH;
                        const reqDy = (ha + hb) / 2 + padH;
                        const dx = Math.abs(b.x - a.x);
                        const dy = Math.abs(b.y - a.y);
                        if (dx < reqDx && dy < reqDy) {
                            const overlapX = reqDx - dx;
                            const overlapY = reqDy - dy;
                            // Bias: prefer horizontal push (side-by-side) unless vertical overlap is much smaller
                            if (overlapX * 0.5 < overlapY) {
                                const sign = Math.sign(b.x - a.x) || 1;
                                a.x -= sign * overlapX / 2;
                                b.x += sign * overlapX / 2;
                            } else {
                                const sign = Math.sign(b.y - a.y) || 1;
                                a.y -= sign * overlapY / 2;
                                b.y += sign * overlapY / 2;
                            }
                        }
                    }
                }

                // Hard circular separation for origin vs all other nodes
                if (originNode_ !== draggedNode) {
                    const oRad = 150; // origin collision radius (ellipse)
                    for (const other of nodes) {
                        if (other === originNode_ || other === draggedNode) continue;
                        const otherRad = getCollisionRadius(other);
                        const minDist = oRad + otherRad;
                        const dx = other.x - originNode_.x;
                        const dy = other.y - originNode_.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist && dist > 0) {
                            const overlap = minDist - dist;
                            const nx = dx / dist;
                            const ny = dy / dist;
                            other.x += nx * overlap / 2;
                            other.y += ny * overlap / 2;
                            originNode_.x -= nx * overlap / 2;
                            originNode_.y -= ny * overlap / 2;
                        }
                    }
                }

                // Hard separation for person nodes vs orgs — no padding, just prevent overlap
                for (const p of personList) {
                    if (p === draggedNode) continue;
                    const pw = getNodeWidth(p);
                    const ph = getNodeHeight(p);
                    for (const other of orgList) {
                        if (other === draggedNode) continue;
                        const ow = getNodeWidth(other);
                        const oh = getNodeHeight(other);
                        const reqDx = (pw + ow) / 2;
                        const reqDy = (ph + oh) / 2;
                        const dx = Math.abs(other.x - p.x);
                        const dy = Math.abs(other.y - p.y);
                        if (dx < reqDx && dy < reqDy) {
                            const overlapX = reqDx - dx;
                            const overlapY = reqDy - dy;
                            if (overlapX < overlapY) {
                                const sign = Math.sign(other.x - p.x) || 1;
                                p.x -= sign * overlapX / 2;
                                other.x += sign * overlapX / 2;
                            } else {
                                const sign = Math.sign(other.y - p.y) || 1;
                                p.y -= sign * overlapY / 2;
                                other.y += sign * overlapY / 2;
                            }
                        }
                    }
                }

                // Hard legend separation — push nodes away from legend with half-height padding
                const lcx = legendBox.x + legendBox.w / 2;
                const lcy = legendBox.y + legendBox.h / 2;
                for (const a of nodes) {
                    if (a.type === "origin" || a === draggedNode) continue;
                    const ha = getNodeHeight(a);
                    const wa = getNodeWidth(a);
                    const padH = ha / 2;
                    const reqDx = wa / 2 + legendBox.w / 2 + padH;
                    const reqDy = ha / 2 + legendBox.h / 2 + padH;
                    const dx = Math.abs(a.x - lcx);
                    const dy = Math.abs(a.y - lcy);
                    if (dx < reqDx && dy < reqDy) {
                        const overlapX = reqDx - dx;
                        const overlapY = reqDy - dy;
                        if (overlapX < overlapY) {
                            a.x += (Math.sign(a.x - lcx) || -1) * overlapX;
                        } else {
                            a.y += (Math.sign(a.y - lcy) || -1) * overlapY;
                        }
                    }
                }

                // Regular links: center-to-center
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                // Acquisition arrows: midpoint weighted by collision radii
                acqLink.attr("d", d => {
                    const sr = getCollisionRadius(d.source);
                    const tr = getCollisionRadius(d.target);
                    const t = sr / (sr + tr);
                    const mx = d.source.x + t * (d.target.x - d.source.x);
                    const my = d.source.y + t * (d.target.y - d.source.y);
                    return `M${d.source.x},${d.source.y} L${mx},${my} L${d.target.x},${d.target.y}`;
                });

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            //
            // Drag behavior for nodes
            //
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
                draggedNode = event.subject;
                // Zero collide radius so dragged node passes through others
                simulation.force("collide").radius(d => d === draggedNode ? 0 : getCollisionRadius(d));
                d3.select(this).style("cursor", "grabbing");
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
                draggedNode = null;
                // Restore normal collide radii
                simulation.force("collide").radius(d => getCollisionRadius(d));
                d3.select(this).style("cursor", "grab");
            }

            //
            // Responsive resize
            //
            function resize() {
                width = container.clientWidth;
                height = container.clientHeight;
                ({ vw, vh } = computeVirtual(width, height));
                svg
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", [-vw / 2, -vh / 2, vw, vh]);

                boundary.resize(vw, vh);

                // Reposition legend for new virtual dimensions
                legendPos.x = -vw / 2 + legendEdgePad + legendPadding;
                legendPos.y = vh / 2 - legendTotalH - legendEdgePad + legendPadding;
                updateLegendBox();
                legend.attr("transform", `translate(${legendPos.x}, ${legendPos.y})`);

                simulation.alpha(0.3).restart();
            }

            window.addEventListener("resize", resize);
        })();
    </script>
</body>

</html>
